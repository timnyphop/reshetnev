"use strict";
/* eslint-disable @typescript-eslint/require-await */
/**
 * @license
 * Copyright Google LLC All Rights Reserved.
 *
 * Use of this source code is governed by an MIT-style license that can be
 * found in the LICENSE file at https://angular.io/license
 */
Object.defineProperty(exports, "__esModule", { value: true });
exports.NgCliFileSystem = exports.FileSystem = void 0;
const tslib_1 = require("tslib");
const node_path_1 = require("node:path");
const multimatch_1 = tslib_1.__importDefault(require("multimatch"));
/**
 * Abstraction of the file system that migrations can use to record and apply
 * changes. This is necessary to support virtual file systems as used in the CLI devkit.
 */
class FileSystem {
}
exports.FileSystem = FileSystem;
class NgCliFileSystem {
    constructor(fs) {
        this.fs = fs;
    }
    async copy(srcPath, destPath) {
        this.copySync(srcPath, destPath);
    }
    copySync(srcPath, destPath) {
        if (this.fileExistsSync(srcPath)) {
            this.writeFileSync(destPath, this.readFileSync(srcPath));
        }
        else if (this.directoryExistsSync(srcPath)) {
            const paths = this.readDirSync(srcPath);
            paths.forEach((path) => this.copySync(path.name, (0, node_path_1.join)(destPath, (0, node_path_1.basename)(path.name))));
        }
    }
    async delete(path) {
        this.deleteSync(path);
    }
    deleteSync(path) {
        this.fs.delete(path);
    }
    async directoryExists(dirPath) {
        return this.directoryExistsSync(dirPath);
    }
    directoryExistsSync(dirPath) {
        return this.fs.exists(dirPath) && !this.fileExistsSync(dirPath);
    }
    async fileExists(filePath) {
        return this.fileExistsSync(filePath);
    }
    fileExistsSync(filePath) {
        try {
            return this.fs.read(filePath) !== null;
        }
        catch (_a) {
            return false;
        }
    }
    getCurrentDirectory() {
        return '/';
    }
    async glob(patterns) {
        return this.globSync(patterns);
    }
    globSync(patterns) {
        return (0, multimatch_1.default)(this.getAllFilePaths(), patterns);
    }
    isCaseSensitive() {
        return true;
    }
    // eslint-disable-next-line @typescript-eslint/no-unused-vars
    async mkdir(_dirPath) {
        return Promise.resolve(undefined);
    }
    // eslint-disable-next-line @typescript-eslint/no-unused-vars
    mkdirSync(_dirPath) {
        // empty
    }
    async move(srcPath, destPath) {
        this.moveSync(srcPath, destPath);
    }
    moveSync(srcPath, destPath) {
        this.copySync(srcPath, destPath);
        this.deleteSync(srcPath);
    }
    readDirSync(dirPath) {
        const { directories, files } = this.fs.readDirectory(dirPath);
        return directories
            .map((name) => ({
            name,
            isFile: false,
            isDirectory: true,
            isSymlink: false,
        }))
            .concat(files.map((name) => ({
            name,
            isFile: true,
            isDirectory: false,
            isSymlink: false,
        })));
    }
    // eslint-disable-next-line @typescript-eslint/no-unused-vars
    async readFile(filePath, _encoding) {
        return this.readFileSync(filePath);
    }
    // eslint-disable-next-line @typescript-eslint/no-unused-vars
    readFileSync(filePath, _encoding) {
        var _a;
        return (_a = this.fs.read(filePath)) !== null && _a !== void 0 ? _a : '';
    }
    realpathSync(path) {
        return path;
    }
    async writeFile(filePath, fileText) {
        this.writeFileSync(filePath, fileText);
    }
    writeFileSync(filePath, fileText) {
        if (this.fileExistsSync(filePath)) {
            this.fs.overwrite(filePath, fileText);
        }
        else {
            this.fs.create(filePath, fileText);
        }
    }
    getAllFilePaths(path = '/', foundedFiles = []) {
        const { directories, files } = this.fs.readDirectory(path);
        foundedFiles.push(...files.map((file) => (0, node_path_1.join)(path, file)));
        directories
            .filter((dir) => !dir.startsWith('.') && dir !== 'node_modules')
            .forEach((dir) => this.getAllFilePaths((0, node_path_1.join)(path, dir), foundedFiles));
        return foundedFiles;
    }
}
exports.NgCliFileSystem = NgCliFileSystem;
//# sourceMappingURL=file-system.js.map