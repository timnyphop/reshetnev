import { AsyncPipe } from '@angular/common';
import { ChangeDetectionStrategy, ChangeDetectorRef, Component, ElementRef, inject, Input, NgZone, Output, Renderer2, signal, ViewChild, } from '@angular/core';
import { WaResizeObserver } from '@ng-web-apis/resize-observer';
import { TuiLet } from '@taiga-ui/cdk/directives/let';
import { tuiTypedFromEvent, tuiZonefree } from '@taiga-ui/cdk/observables';
import { tuiInjectElement, tuiIsCurrentTarget } from '@taiga-ui/cdk/utils/dom';
import { tuiPx } from '@taiga-ui/cdk/utils/miscellaneous';
import { TUI_HINT_COMPONENT, TuiHint, TuiHintDirective, } from '@taiga-ui/core/directives/hint';
import { PolymorpheusOutlet, PolymorpheusTemplate } from '@taiga-ui/polymorpheus';
import { BehaviorSubject, distinctUntilChanged, filter, map, of, pairwise, startWith, Subject, switchMap, timer, } from 'rxjs';
import { TUI_LINE_CLAMP_OPTIONS } from './line-clamp.options';
import { TuiLineClampBox } from './line-clamp-box.component';
import { TuiLineClampPositionDirective } from './line-clamp-position.directive';
import * as i0 from "@angular/core";
import * as i1 from "@taiga-ui/core/directives/hint";
class TuiLineClamp {
    constructor() {
        this.options = inject(TUI_LINE_CLAMP_OPTIONS);
        this.el = tuiInjectElement();
        this.renderer = inject(Renderer2);
        this.cd = inject(ChangeDetectorRef);
        this.zone = inject(NgZone);
        this.linesLimit$ = new BehaviorSubject(1);
        this.isOverflown$ = new Subject();
        this.initialized = signal(false);
        this.lineClamp$ = this.linesLimit$.pipe(startWith(1), pairwise(), switchMap(([prev, next]) => next >= prev
            ? of(next)
            : tuiTypedFromEvent(this.el, 'transitionend').pipe(filter(tuiIsCurrentTarget), map(() => next))));
        this.lineHeight = 24;
        this.overflownChange = this.isOverflown$.pipe(distinctUntilChanged());
        this.skipInitialTransition();
    }
    set linesLimit(linesLimit) {
        this.linesLimit$.next(linesLimit);
    }
    ngDoCheck() {
        this.update();
        this.isOverflown$.next(this.overflown);
    }
    ngAfterViewInit() {
        this.initialized.set(true);
    }
    get overflown() {
        if (!this.outlet) {
            return false;
        }
        const { scrollHeight, scrollWidth } = this.outlet.nativeElement;
        const { clientHeight, clientWidth } = this.el;
        // 4px buffer for IE/Edge incorrectly rounding scrollHeight
        return scrollHeight - clientHeight > 4 || scrollWidth - clientWidth > 0;
    }
    get computedContent() {
        return this.options.showHint && this.overflown ? this.content : '';
    }
    updateView() {
        this.cd.detectChanges();
    }
    skipInitialTransition() {
        timer(0)
            .pipe(tuiZonefree(this.zone))
            .subscribe(() => this.initialized.set(true));
    }
    update() {
        if (this.outlet) {
            this.renderer.setStyle(this.el, 'height', tuiPx(this.outlet.nativeElement.scrollHeight + 4));
        }
        if (this.initialized()) {
            this.renderer.setStyle(this.el, 'max-height', tuiPx(this.lineHeight * this.linesLimit$.value));
        }
    }
    static { this.ɵfac = i0.ɵɵngDeclareFactory({ minVersion: "12.0.0", version: "16.2.12", ngImport: i0, type: TuiLineClamp, deps: [], target: i0.ɵɵFactoryTarget.Component }); }
    static { this.ɵcmp = i0.ɵɵngDeclareComponent({ minVersion: "14.0.0", version: "16.2.12", type: TuiLineClamp, isStandalone: true, selector: "tui-line-clamp", inputs: { lineHeight: "lineHeight", content: "content", linesLimit: "linesLimit" }, outputs: { overflownChange: "overflownChange" }, host: { listeners: { "transitionend": "updateView()" }, properties: { "class._initialized": "initialized()" } }, providers: [
            {
                provide: TUI_HINT_COMPONENT,
                useValue: TuiLineClampBox,
            },
        ], viewQueries: [{ propertyName: "outlet", first: true, predicate: TuiHintDirective, descendants: true, read: ElementRef }], ngImport: i0, template: "<div\n    *tuiLet=\"lineClamp$ | async as lineClamp\"\n    tuiLineClampPosition\n    class=\"t-wrapper\"\n    [style.-webkit-line-clamp]=\"lineClamp\"\n    [style.word-break]=\"(lineClamp || 0) > 1 ? 'break-word' : 'break-all'\"\n    [tuiHint]=\"computedContent\"\n    (mouseenter)=\"updateView()\"\n    (waResizeObserver)=\"updateView()\"\n>\n    <ng-container *polymorpheusOutlet=\"content as text\">\n        {{ text }}\n    </ng-container>\n</div>\n", styles: [":host{position:relative;display:block;overflow:hidden}:host._initialized{transition-property:max-height;transition-duration:var(--tui-duration, .3s);transition-timing-function:ease-in-out}.t-wrapper{display:-webkit-box;-webkit-box-orient:vertical;overflow:hidden;overflow-wrap:anywhere}.t-wrapper ::ng-deep>*{white-space:initial}\n"], dependencies: [{ kind: "pipe", type: AsyncPipe, name: "async" }, { kind: "directive", type: PolymorpheusOutlet, selector: "[polymorpheusOutlet]", inputs: ["polymorpheusOutlet", "polymorpheusOutletContext"] }, { kind: "directive", type: i1.TuiHintDirective, selector: "[tuiHint]:not(ng-container):not(ng-template)", inputs: ["tuiHintContext", "tuiHintAppearance", "tuiHint"] }, { kind: "directive", type: TuiLet, selector: "[tuiLet]", inputs: ["tuiLet"] }, { kind: "directive", type: TuiLineClampPositionDirective, selector: "[tuiLineClampPosition]" }, { kind: "directive", type: WaResizeObserver, selector: "[waResizeObserver]", inputs: ["box"], outputs: ["waResizeObserver"] }], changeDetection: i0.ChangeDetectionStrategy.OnPush }); }
}
export { TuiLineClamp };
i0.ɵɵngDeclareClassMetadata({ minVersion: "12.0.0", version: "16.2.12", ngImport: i0, type: TuiLineClamp, decorators: [{
            type: Component,
            args: [{ standalone: true, selector: 'tui-line-clamp', imports: [
                        AsyncPipe,
                        PolymorpheusOutlet,
                        PolymorpheusTemplate,
                        TuiHint,
                        TuiLet,
                        TuiLineClampPositionDirective,
                        WaResizeObserver,
                    ], changeDetection: ChangeDetectionStrategy.OnPush, providers: [
                        {
                            provide: TUI_HINT_COMPONENT,
                            useValue: TuiLineClampBox,
                        },
                    ], host: {
                        '(transitionend)': 'updateView()',
                        '[class._initialized]': 'initialized()',
                    }, template: "<div\n    *tuiLet=\"lineClamp$ | async as lineClamp\"\n    tuiLineClampPosition\n    class=\"t-wrapper\"\n    [style.-webkit-line-clamp]=\"lineClamp\"\n    [style.word-break]=\"(lineClamp || 0) > 1 ? 'break-word' : 'break-all'\"\n    [tuiHint]=\"computedContent\"\n    (mouseenter)=\"updateView()\"\n    (waResizeObserver)=\"updateView()\"\n>\n    <ng-container *polymorpheusOutlet=\"content as text\">\n        {{ text }}\n    </ng-container>\n</div>\n", styles: [":host{position:relative;display:block;overflow:hidden}:host._initialized{transition-property:max-height;transition-duration:var(--tui-duration, .3s);transition-timing-function:ease-in-out}.t-wrapper{display:-webkit-box;-webkit-box-orient:vertical;overflow:hidden;overflow-wrap:anywhere}.t-wrapper ::ng-deep>*{white-space:initial}\n"] }]
        }], ctorParameters: function () { return []; }, propDecorators: { outlet: [{
                type: ViewChild,
                args: [TuiHintDirective, { read: ElementRef }]
            }], lineHeight: [{
                type: Input
            }], content: [{
                type: Input
            }], overflownChange: [{
                type: Output
            }], linesLimit: [{
                type: Input
            }] } });
//# sourceMappingURL=data:application/json;base64,eyJ2ZXJzaW9uIjozLCJmaWxlIjoibGluZS1jbGFtcC5jb21wb25lbnQuanMiLCJzb3VyY2VSb290IjoiIiwic291cmNlcyI6WyIuLi8uLi8uLi8uLi8uLi9wcm9qZWN0cy9raXQvY29tcG9uZW50cy9saW5lLWNsYW1wL2xpbmUtY2xhbXAuY29tcG9uZW50LnRzIiwiLi4vLi4vLi4vLi4vLi4vcHJvamVjdHMva2l0L2NvbXBvbmVudHMvbGluZS1jbGFtcC9saW5lLWNsYW1wLnRlbXBsYXRlLmh0bWwiXSwibmFtZXMiOltdLCJtYXBwaW5ncyI6IkFBQUEsT0FBTyxFQUFDLFNBQVMsRUFBQyxNQUFNLGlCQUFpQixDQUFDO0FBRTFDLE9BQU8sRUFDSCx1QkFBdUIsRUFDdkIsaUJBQWlCLEVBQ2pCLFNBQVMsRUFDVCxVQUFVLEVBQ1YsTUFBTSxFQUNOLEtBQUssRUFDTCxNQUFNLEVBQ04sTUFBTSxFQUNOLFNBQVMsRUFDVCxNQUFNLEVBQ04sU0FBUyxHQUNaLE1BQU0sZUFBZSxDQUFDO0FBQ3ZCLE9BQU8sRUFBQyxnQkFBZ0IsRUFBQyxNQUFNLDhCQUE4QixDQUFDO0FBQzlELE9BQU8sRUFBQyxNQUFNLEVBQUMsTUFBTSw4QkFBOEIsQ0FBQztBQUNwRCxPQUFPLEVBQUMsaUJBQWlCLEVBQUUsV0FBVyxFQUFDLE1BQU0sMkJBQTJCLENBQUM7QUFDekUsT0FBTyxFQUFDLGdCQUFnQixFQUFFLGtCQUFrQixFQUFDLE1BQU0seUJBQXlCLENBQUM7QUFDN0UsT0FBTyxFQUFDLEtBQUssRUFBQyxNQUFNLG1DQUFtQyxDQUFDO0FBQ3hELE9BQU8sRUFDSCxrQkFBa0IsRUFDbEIsT0FBTyxFQUNQLGdCQUFnQixHQUNuQixNQUFNLGdDQUFnQyxDQUFDO0FBRXhDLE9BQU8sRUFBQyxrQkFBa0IsRUFBRSxvQkFBb0IsRUFBQyxNQUFNLHdCQUF3QixDQUFDO0FBRWhGLE9BQU8sRUFDSCxlQUFlLEVBQ2Ysb0JBQW9CLEVBQ3BCLE1BQU0sRUFDTixHQUFHLEVBQ0gsRUFBRSxFQUNGLFFBQVEsRUFDUixTQUFTLEVBQ1QsT0FB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QUF1QixDQUFDLE1BQU0sYUFDcEM7d0JBQ1A7NEJBQ0ksT0FBTyxFQUFFLGtCQUFrQjs0QkFDM0IsUUFBUSxFQUFFLGVBQWU7eUJBQzVCO3FCQUNKLFFBQ0s7d0JBQ0YsaUJBQWlCLEVBQUUsY0FBYzt3QkFDakMsc0JBQXNCLEVBQUUsZUFBZTtxQkFDMUM7MEVBSWdCLE1BQU07c0JBRHRCLFNBQVM7dUJBQUMsZ0JBQWdCLEVBQUUsRUFBQyxJQUFJLEVBQUUsVUFBVSxFQUFDO2dCQTBCeEMsVUFBVTtzQkFEaEIsS0FBSztnQkFJQyxPQUFPO3NCQURiLEtBQUs7Z0JBSVUsZUFBZTtzQkFEOUIsTUFBTTtnQkFTSSxVQUFVO3NCQURwQixLQUFLIiwic291cmNlc0NvbnRlbnQiOlsiaW1wb3J0IHtBc3luY1BpcGV9IGZyb20gJ0Bhbmd1bGFyL2NvbW1vbic7XG5pbXBvcnQgdHlwZSB7QWZ0ZXJWaWV3SW5pdCwgRG9DaGVja30gZnJvbSAnQGFuZ3VsYXIvY29yZSc7XG5pbXBvcnQge1xuICAgIENoYW5nZURldGVjdGlvblN0cmF0ZWd5LFxuICAgIENoYW5nZURldGVjdG9yUmVmLFxuICAgIENvbXBvbmVudCxcbiAgICBFbGVtZW50UmVmLFxuICAgIGluamVjdCxcbiAgICBJbnB1dCxcbiAgICBOZ1pvbmUsXG4gICAgT3V0cHV0LFxuICAgIFJlbmRlcmVyMixcbiAgICBzaWduYWwsXG4gICAgVmlld0NoaWxkLFxufSBmcm9tICdAYW5ndWxhci9jb3JlJztcbmltcG9ydCB7V2FSZXNpemVPYnNlcnZlcn0gZnJvbSAnQG5nLXdlYi1hcGlzL3Jlc2l6ZS1vYnNlcnZlcic7XG5pbXBvcnQge1R1aUxldH0gZnJvbSAnQHRhaWdhLXVpL2Nkay9kaXJlY3RpdmVzL2xldCc7XG5pbXBvcnQge3R1aVR5cGVkRnJvbUV2ZW50LCB0dWlab25lZnJlZX0gZnJvbSAnQHRhaWdhLXVpL2Nkay9vYnNlcnZhYmxlcyc7XG5pbXBvcnQge3R1aUluamVjdEVsZW1lbnQsIHR1aUlzQ3VycmVudFRhcmdldH0gZnJvbSAnQHRhaWdhLXVpL2Nkay91dGlscy9kb20nO1xuaW1wb3J0IHt0dWlQeH0gZnJvbSAnQHRhaWdhLXVpL2Nkay91dGlscy9taXNjZWxsYW5lb3VzJztcbmltcG9ydCB7XG4gICAgVFVJX0hJTlRfQ09NUE9ORU5ULFxuICAgIFR1aUhpbnQsXG4gICAgVHVpSGludERpcmVjdGl2ZSxcbn0gZnJvbSAnQHRhaWdhLXVpL2NvcmUvZGlyZWN0aXZlcy9oaW50JztcbmltcG9ydCB0eXBlIHtQb2x5bW9ycGhldXNDb250ZW50fSBmcm9tICdAdGFpZ2EtdWkvcG9seW1vcnBoZXVzJztcbmltcG9ydCB7UG9seW1vcnBoZXVzT3V0bGV0LCBQb2x5bW9ycGhldXNUZW1wbGF0ZX0gZnJvbSAnQHRhaWdhLXVpL3BvbHltb3JwaGV1cyc7XG5pbXBvcnQgdHlwZSB7T2JzZXJ2YWJsZX0gZnJvbSAncnhqcyc7XG5pbXBvcnQge1xuICAgIEJlaGF2aW9yU3ViamVjdCxcbiAgICBkaXN0aW5jdFVudGlsQ2hhbmdlZCxcbiAgICBmaWx0ZXIsXG4gICAgbWFwLFxuICAgIG9mLFxuICAgIHBhaXJ3aXNlLFxuICAgIHN0YXJ0V2l0aCxcbiAgICBTdWJqZWN0LFxuICAgIHN3aXRjaE1hcCxcbiAgICB0aW1lcixcbn0gZnJvbSAncnhqcyc7XG5cbmltcG9ydCB7VFVJX0xJTkVfQ0xBTVBfT1BUSU9OU30gZnJvbSAnLi9saW5lLWNsYW1wLm9wdGlvbnMnO1xuaW1wb3J0IHtUdWlMaW5lQ2xhbXBCb3h9IGZyb20gJy4vbGluZS1jbGFtcC1ib3guY29tcG9uZW50JztcbmltcG9ydCB7VHVpTGluZUNsYW1wUG9zaXRpb25EaXJlY3RpdmV9IGZyb20gJy4vbGluZS1jbGFtcC1wb3NpdGlvbi5kaXJlY3RpdmUnO1xuXG5AQ29tcG9uZW50KHtcbiAgICBzdGFuZGFsb25lOiB0cnVlLFxuICAgIHNlbGVjdG9yOiAndHVpLWxpbmUtY2xhbXAnLFxuICAgIGltcG9ydHM6IFtcbiAgICAgICAgQXN5bmNQaXBlLFxuICAgICAgICBQb2x5bW9ycGhldXNPdXRsZXQsXG4gICAgICAgIFBvbHltb3JwaGV1c1RlbXBsYXRlLFxuICAgICAgICBUdWlIaW50LFxuICAgICAgICBUdWlMZXQsXG4gICAgICAgIFR1aUxpbmVDbGFtcFBvc2l0aW9uRGlyZWN0aXZlLFxuICAgICAgICBXYVJlc2l6ZU9ic2VydmVyLFxuICAgIF0sXG4gICAgdGVtcGxhdGVVcmw6ICcuL2xpbmUtY2xhbXAudGVtcGxhdGUuaHRtbCcsXG4gICAgc3R5bGVVcmxzOiBbJy4vbGluZS1jbGFtcC5zdHlsZS5sZXNzJ10sXG4gICAgY2hhbmdlRGV0ZWN0aW9uOiBDaGFuZ2VEZXRlY3Rpb25TdHJhdGVneS5PblB1c2gsXG4gICAgcHJvdmlkZXJzOiBbXG4gICAgICAgIHtcbiAgICAgICAgICAgIHByb3ZpZGU6IFRVSV9ISU5UX0NPTVBPTkVOVCxcbiAgICAgICAgICAgIHVzZVZhbHVlOiBUdWlMaW5lQ2xhbXBCb3gsXG4gICAgICAgIH0sXG4gICAgXSxcbiAgICBob3N0OiB7XG4gICAgICAgICcodHJhbnNpdGlvbmVuZCknOiAndXBkYXRlVmlldygpJyxcbiAgICAgICAgJ1tjbGFzcy5faW5pdGlhbGl6ZWRdJzogJ2luaXRpYWxpemVkKCknLFxuICAgIH0sXG59KVxuZXhwb3J0IGNsYXNzIFR1aUxpbmVDbGFtcCBpbXBsZW1lbnRzIERvQ2hlY2ssIEFmdGVyVmlld0luaXQge1xuICAgIEBWaWV3Q2hpbGQoVHVpSGludERpcmVjdGl2ZSwge3JlYWQ6IEVsZW1lbnRSZWZ9KVxuICAgIHByaXZhdGUgcmVhZG9ubHkgb3V0bGV0PzogRWxlbWVudFJlZjxIVE1MRWxlbWVudD47XG5cbiAgICBwcml2YXRlIHJlYWRvbmx5IG9wdGlvbnMgPSBpbmplY3QoVFVJX0xJTkVfQ0xBTVBfT1BUSU9OUyk7XG4gICAgcHJpdmF0ZSByZWFkb25seSBlbCA9IHR1aUluamVjdEVsZW1lbnQoKTtcbiAgICBwcml2YXRlIHJlYWRvbmx5IHJlbmRlcmVyID0gaW5qZWN0KFJlbmRlcmVyMik7XG4gICAgcHJpdmF0ZSByZWFkb25seSBjZCA9IGluamVjdChDaGFuZ2VEZXRlY3RvclJlZik7XG4gICAgcHJpdmF0ZSByZWFkb25seSB6b25lOiBOZ1pvbmUgPSBpbmplY3QoTmdab25lKTtcbiAgICBwcml2YXRlIHJlYWRvbmx5IGxpbmVzTGltaXQkID0gbmV3IEJlaGF2aW9yU3ViamVjdCgxKTtcbiAgICBwcml2YXRlIHJlYWRvbmx5IGlzT3ZlcmZsb3duJCA9IG5ldyBTdWJqZWN0PGJvb2xlYW4+KCk7XG4gICAgcHJvdGVjdGVkIGluaXRpYWxpemVkID0gc2lnbmFsKGZhbHNlKTtcblxuICAgIHByb3RlY3RlZCBsaW5lQ2xhbXAkID0gdGhpcy5saW5lc0xpbWl0JC5waXBlKFxuICAgICAgICBzdGFydFdpdGgoMSksXG4gICAgICAgIHBhaXJ3aXNlKCksXG4gICAgICAgIHN3aXRjaE1hcCgoW3ByZXYsIG5leHRdKSA9PlxuICAgICAgICAgICAgbmV4dCA+PSBwcmV2XG4gICAgICAgICAgICAgICAgPyBvZihuZXh0KVxuICAgICAgICAgICAgICAgIDogdHVpVHlwZWRGcm9tRXZlbnQodGhpcy5lbCwgJ3RyYW5zaXRpb25lbmQnKS5waXBlKFxuICAgICAgICAgICAgICAgICAgICAgIGZpbHRlcih0dWlJc0N1cnJlbnRUYXJnZXQpLFxuICAgICAgICAgICAgICAgICAgICAgIG1hcCgoKSA9PiBuZXh0KSxcbiAgICAgICAgICAgICAgICAgICksXG4gICAgICAgICksXG4gICAgKTtcblxuICAgIEBJbnB1dCgpXG4gICAgcHVibGljIGxpbmVIZWlnaHQgPSAyNDtcblxuICAgIEBJbnB1dCgpXG4gICAgcHVibGljIGNvbnRlbnQ6IFBvbHltb3JwaGV1c0NvbnRlbnQ7XG5cbiAgICBAT3V0cHV0KClcbiAgICBwdWJsaWMgcmVhZG9ubHkgb3ZlcmZsb3duQ2hhbmdlOiBPYnNlcnZhYmxlPGJvb2xlYW4+ID1cbiAgICAgICAgdGhpcy5pc092ZXJmbG93biQucGlwZShkaXN0aW5jdFVudGlsQ2hhbmdlZCgpKTtcblxuICAgIGNvbnN0cnVjdG9yKCkge1xuICAgICAgICB0aGlzLnNraXBJbml0aWFsVHJhbnNpdGlvbigpO1xuICAgIH1cblxuICAgIEBJbnB1dCgpXG4gICAgcHVibGljIHNldCBsaW5lc0xpbWl0KGxpbmVzTGltaXQ6IG51bWJlcikge1xuICAgICAgICB0aGlzLmxpbmVzTGltaXQkLm5leHQobGluZXNMaW1pdCk7XG4gICAgfVxuXG4gICAgcHVibGljIG5nRG9DaGVjaygpOiB2b2lkIHtcbiAgICAgICAgdGhpcy51cGRhdGUoKTtcbiAgICAgICAgdGhpcy5pc092ZXJmbG93biQubmV4dCh0aGlzLm92ZXJmbG93bik7XG4gICAgfVxuXG4gICAgcHVibGljIG5nQWZ0ZXJWaWV3SW5pdCgpOiB2b2lkIHtcbiAgICAgICAgdGhpcy5pbml0aWFsaXplZC5zZXQodHJ1ZSk7XG4gICAgfVxuXG4gICAgcHJvdGVjdGVkIGdldCBvdmVyZmxvd24oKTogYm9vbGVhbiB7XG4gICAgICAgIGlmICghdGhpcy5vdXRsZXQpIHtcbiAgICAgICAgICAgIHJldHVybiBmYWxzZTtcbiAgICAgICAgfVxuXG4gICAgICAgIGNvbnN0IHtzY3JvbGxIZWlnaHQsIHNjcm9sbFdpZHRofSA9IHRoaXMub3V0bGV0Lm5hdGl2ZUVsZW1lbnQ7XG4gICAgICAgIGNvbnN0IHtjbGllbnRIZWlnaHQsIGNsaWVudFdpZHRofSA9IHRoaXMuZWw7XG5cbiAgICAgICAgLy8gNHB4IGJ1ZmZlciBmb3IgSUUvRWRnZSBpbmNvcnJlY3RseSByb3VuZGluZyBzY3JvbGxIZWlnaHRcbiAgICAgICAgcmV0dXJuIHNjcm9sbEhlaWdodCAtIGNsaWVudEhlaWdodCA+IDQgfHwgc2Nyb2xsV2lkdGggLSBjbGllbnRXaWR0aCA+IDA7XG4gICAgfVxuXG4gICAgcHJvdGVjdGVkIGdldCBjb21wdXRlZENvbnRlbnQoKTogUG9seW1vcnBoZXVzQ29udGVudCB7XG4gICAgICAgIHJldHVybiB0aGlzLm9wdGlvbnMuc2hvd0hpbnQgJiYgdGhpcy5vdmVyZmxvd24gPyB0aGlzLmNvbnRlbnQgOiAnJztcbiAgICB9XG5cbiAgICBwcm90ZWN0ZWQgdXBkYXRlVmlldygpOiB2b2lkIHtcbiAgICAgICAgdGhpcy5jZC5kZXRlY3RDaGFuZ2VzKCk7XG4gICAgfVxuXG4gICAgcHJpdmF0ZSBza2lwSW5pdGlhbFRyYW5zaXRpb24oKTogdm9pZCB7XG4gICAgICAgIHRpbWVyKDApXG4gICAgICAgICAgICAucGlwZSh0dWlab25lZnJlZSh0aGlzLnpvbmUpKVxuICAgICAgICAgICAgLnN1YnNjcmliZSgoKSA9PiB0aGlzLmluaXRpYWxpemVkLnNldCh0cnVlKSk7XG4gICAgfVxuXG4gICAgcHJpdmF0ZSB1cGRhdGUoKTogdm9pZCB7XG4gICAgICAgIGlmICh0aGlzLm91dGxldCkge1xuICAgICAgICAgICAgdGhpcy5yZW5kZXJlci5zZXRTdHlsZShcbiAgICAgICAgICAgICAgICB0aGlzLmVsLFxuICAgICAgICAgICAgICAgICdoZWlnaHQnLFxuICAgICAgICAgICAgICAgIHR1aVB4KHRoaXMub3V0bGV0Lm5hdGl2ZUVsZW1lbnQuc2Nyb2xsSGVpZ2h0ICsgNCksXG4gICAgICAgICAgICApO1xuICAgICAgICB9XG5cbiAgICAgICAgaWYgKHRoaXMuaW5pdGlhbGl6ZWQoKSkge1xuICAgICAgICAgICAgdGhpcy5yZW5kZXJlci5zZXRTdHlsZShcbiAgICAgICAgICAgICAgICB0aGlzLmVsLFxuICAgICAgICAgICAgICAgICdtYXgtaGVpZ2h0JyxcbiAgICAgICAgICAgICAgICB0dWlQeCh0aGlzLmxpbmVIZWlnaHQgKiB0aGlzLmxpbmVzTGltaXQkLnZhbHVlKSxcbiAgICAgICAgICAgICk7XG4gICAgICAgIH1cbiAgICB9XG59XG4iLCI8ZGl2XG4gICAgKnR1aUxldD1cImxpbmVDbGFtcCQgfCBhc3luYyBhcyBsaW5lQ2xhbXBcIlxuICAgIHR1aUxpbmVDbGFtcFBvc2l0aW9uXG4gICAgY2xhc3M9XCJ0LXdyYXBwZXJcIlxuICAgIFtzdHlsZS4td2Via2l0LWxpbmUtY2xhbXBdPVwibGluZUNsYW1wXCJcbiAgICBbc3R5bGUud29yZC1icmVha109XCIobGluZUNsYW1wIHx8IDApID4gMSA/ICdicmVhay13b3JkJyA6ICdicmVhay1hbGwnXCJcbiAgICBbdHVpSGludF09XCJjb21wdXRlZENvbnRlbnRcIlxuICAgIChtb3VzZWVudGVyKT1cInVwZGF0ZVZpZXcoKVwiXG4gICAgKHdhUmVzaXplT2JzZXJ2ZXIpPVwidXBkYXRlVmlldygpXCJcbj5cbiAgICA8bmctY29udGFpbmVyICpwb2x5bW9ycGhldXNPdXRsZXQ9XCJjb250ZW50IGFzIHRleHRcIj5cbiAgICAgICAge3sgdGV4dCB9fVxuICAgIDwvbmctY29udGFpbmVyPlxuPC9kaXY+XG4iXX0=