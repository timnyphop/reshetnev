/// <reference types="@taiga-ui/tsconfig/ng-dev-mode" />
import { tuiInRange, tuiNormalizeToIntNumber } from '@taiga-ui/cdk/utils/math';
import { MAX_YEAR, MIN_YEAR } from './date-time';
/**
 * Immutable year object
 * @nosideeffects
 */
export class TuiYear {
    constructor(year) {
        this.year = year;
        ngDevMode && console.assert(TuiYear.isValidYear(year));
    }
    /**
     * Checks year for validity
     */
    static isValidYear(year) {
        return Number.isInteger(year) && tuiInRange(year, MIN_YEAR, MAX_YEAR + 1);
    }
    /**
     * Check if passed year is a leap year
     */
    static isLeapYear(year) {
        ngDevMode && console.assert(TuiYear.isValidYear(year));
        return year % 400 === 0 || (year % 4 === 0 && year % 100 !== 0);
    }
    /**
     * Returns amount of leap years from year 0 to the passed one
     */
    static getAbsoluteLeapYears(year) {
        ngDevMode && console.assert(TuiYear.isValidYear(year));
        return Math.ceil(year / 400) + (Math.ceil(year / 4) - Math.ceil(year / 100));
    }
    static lengthBetween(from, to) {
        return to.year - from.year;
    }
    /**
     * Normalizes year by clamping it between min and max years
     */
    static normalizeYearPart(year) {
        return tuiNormalizeToIntNumber(year, MIN_YEAR, MAX_YEAR);
    }
    get formattedYear() {
        return String(this.year).padStart(4, '0');
    }
    get isLeapYear() {
        return TuiYear.isLeapYear(this.year);
    }
    /**
     * Returns amount of leap years from year 0 to current
     */
    get absoluteLeapYears() {
        return TuiYear.getAbsoluteLeapYears(this.year);
    }
    /**
     * Passed year is after current
     */
    yearBefore({ year }) {
        return this.year < year;
    }
    /**
     * Passed year is the same or after current
     */
    yearSameOrBefore({ year }) {
        return this.year <= year;
    }
    /**
     * Passed year is the same as current
     */
    yearSame({ year }) {
        return this.year === year;
    }
    /**
     * Passed year is either the same of before the current
     */
    yearSameOrAfter({ year }) {
        return this.year >= year;
    }
    /**
     * Passed year is before current
     */
    yearAfter({ year }) {
        return this.year > year;
    }
    /**
     * Immutably offsets year
     */
    append({ year = 0 }) {
        ngDevMode && console.assert(Number.isInteger(year));
        const resultYear = this.year + year;
        ngDevMode && console.assert(TuiYear.isValidYear(resultYear));
        return new TuiYear(resultYear);
    }
    toString() {
        return this.formattedYear;
    }
    valueOf() {
        return this.year;
    }
    /**
     * Returns the primitive value of the given Date object.
     * Depending on the argument, the method can return either a string or a number.
     * @see https://developer.mozilla.org/en-US/docs/Web/JavaScript/Reference/Global_Objects/Date/@@toPrimitive
     */
    [Symbol.toPrimitive](hint) {
        return Date.prototype[Symbol.toPrimitive].call(this, hint);
    }
    toJSON() {
        return this.formattedYear;
    }
}
//# sourceMappingURL=data:application/json;base64,eyJ2ZXJzaW9uIjozLCJmaWxlIjoieWVhci5qcyIsInNvdXJjZVJvb3QiOiIiLCJzb3VyY2VzIjpbIi4uLy4uLy4uLy4uL3Byb2plY3RzL2Nkay9kYXRlLXRpbWUveWVhci50cyJdLCJuYW1lcyI6W10sIm1hcHBpbmdzIjoiQUFBQSx3REFBd0Q7QUFDeEQsT0FBTyxFQUFDLFVBQVUsRUFBRSx1QkFBdUIsRUFBQyxNQUFNLDBCQUEwQixDQUFDO0FBRTdFLE9BQU8sRUFBQyxRQUFRLEVBQUUsUUFBUSxFQUFDLE1BQU0sYUFBYSxDQUFDO0FBRy9DOzs7R0FHRztBQUNILE1BQU0sT0FBTyxPQUFPO0lBQ2hCLFlBQTRCLElBQVk7UUFBWixTQUFJLEdBQUosSUFBSSxDQUFRO1FBQ3BDLFNBQVMsSUFBSSxPQUFPLENBQUMsTUFBTSxDQUFDLE9BQU8sQ0FBQyxXQUFXLENBQUMsSUFBSSxDQUFDLENBQUMsQ0FBQztJQUMzRCxDQUFDO0lBRUQ7O09BRUc7SUFDSSxNQUFNLENBQUMsV0FBVyxDQUFDLElBQVk7UUFDbEMsT0FBTyxNQUFNLENBQUMsU0FBUyxDQUFDLElBQUksQ0FBQyxJQUFJLFVBQVUsQ0FBQyxJQUFJLEVBQUUsUUFBUSxFQUFFLFFBQVEsR0FBRyxDQUFDLENBQUMsQ0FBQztJQUM5RSxDQUFDO0lBRUQ7O09BRUc7SUFDSSxNQUFNLENBQUMsVUFBVSxDQUFDLElBQVk7UUFDakMsU0FBUyxJQUFJLE9BQU8sQ0FBQyxNQUFNLENBQUMsT0FBTyxDQUFDLFdBQVcsQ0FBQyxJQUFJLENBQUMsQ0FBQyxDQUFDO1FBRXZELE9BQU8sSUFBSSxHQUFHLEdBQUcsS0FBSyxDQUFDLElBQUksQ0FBQyxJQUFJLEdBQUcsQ0FBQyxLQUFLLENBQUMsSUFBSSxJQUFJLEdBQUcsR0FBRyxLQUFLLENBQUMsQ0FBQyxDQUFDO0lBQ3BFLENBQUM7SUFFRDs7T0FFRztJQUNJLE1BQU0sQ0FBQyxvQkFBb0IsQ0FBQyxJQUFZO1FBQzNDLFNBQVMsSUFBSSxPQUFPLENBQUMsTUFBTSxDQUFDLE9BQU8sQ0FBQyxXQUFXLENBQUMsSUFB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ZW5jZSB0eXBlcz1cIkB0YWlnYS11aS90c2NvbmZpZy9uZy1kZXYtbW9kZVwiIC8+XG5pbXBvcnQge3R1aUluUmFuZ2UsIHR1aU5vcm1hbGl6ZVRvSW50TnVtYmVyfSBmcm9tICdAdGFpZ2EtdWkvY2RrL3V0aWxzL21hdGgnO1xuXG5pbXBvcnQge01BWF9ZRUFSLCBNSU5fWUVBUn0gZnJvbSAnLi9kYXRlLXRpbWUnO1xuaW1wb3J0IHR5cGUge1R1aVllYXJMaWtlfSBmcm9tICcuL3R5cGVzJztcblxuLyoqXG4gKiBJbW11dGFibGUgeWVhciBvYmplY3RcbiAqIEBub3NpZGVlZmZlY3RzXG4gKi9cbmV4cG9ydCBjbGFzcyBUdWlZZWFyIGltcGxlbWVudHMgVHVpWWVhckxpa2Uge1xuICAgIGNvbnN0cnVjdG9yKHB1YmxpYyByZWFkb25seSB5ZWFyOiBudW1iZXIpIHtcbiAgICAgICAgbmdEZXZNb2RlICYmIGNvbnNvbGUuYXNzZXJ0KFR1aVllYXIuaXNWYWxpZFllYXIoeWVhcikpO1xuICAgIH1cblxuICAgIC8qKlxuICAgICAqIENoZWNrcyB5ZWFyIGZvciB2YWxpZGl0eVxuICAgICAqL1xuICAgIHB1YmxpYyBzdGF0aWMgaXNWYWxpZFllYXIoeWVhcjogbnVtYmVyKTogYm9vbGVhbiB7XG4gICAgICAgIHJldHVybiBOdW1iZXIuaXNJbnRlZ2VyKHllYXIpICYmIHR1aUluUmFuZ2UoeWVhciwgTUlOX1lFQVIsIE1BWF9ZRUFSICsgMSk7XG4gICAgfVxuXG4gICAgLyoqXG4gICAgICogQ2hlY2sgaWYgcGFzc2VkIHllYXIgaXMgYSBsZWFwIHllYXJcbiAgICAgKi9cbiAgICBwdWJsaWMgc3RhdGljIGlzTGVhcFllYXIoeWVhcjogbnVtYmVyKTogYm9vbGVhbiB7XG4gICAgICAgIG5nRGV2TW9kZSAmJiBjb25zb2xlLmFzc2VydChUdWlZZWFyLmlzVmFsaWRZZWFyKHllYXIpKTtcblxuICAgICAgICByZXR1cm4geWVhciAlIDQwMCA9PT0gMCB8fCAoeWVhciAlIDQgPT09IDAgJiYgeWVhciAlIDEwMCAhPT0gMCk7XG4gICAgfVxuXG4gICAgLyoqXG4gICAgICogUmV0dXJucyBhbW91bnQgb2YgbGVhcCB5ZWFycyBmcm9tIHllYXIgMCB0byB0aGUgcGFzc2VkIG9uZVxuICAgICAqL1xuICAgIHB1YmxpYyBzdGF0aWMgZ2V0QWJzb2x1dGVMZWFwWWVhcnMoeWVhcjogbnVtYmVyKTogbnVtYmVyIHtcbiAgICAgICAgbmdEZXZNb2RlICYmIGNvbnNvbGUuYXNzZXJ0KFR1aVllYXIuaXNWYWxpZFllYXIoeWVhcikpO1xuXG4gICAgICAgIHJldHVybiBNYXRoLmNlaWwoeWVhciAvIDQwMCkgKyAoTWF0aC5jZWlsKHllYXIgLyA0KSAtIE1hdGguY2VpbCh5ZWFyIC8gMTAwKSk7XG4gICAgfVxuXG4gICAgcHVibGljIHN0YXRpYyBsZW5ndGhCZXR3ZWVuKGZyb206IFR1aVllYXIsIHRvOiBUdWlZZWFyKTogbnVtYmVyIHtcbiAgICAgICAgcmV0dXJuIHRvLnllYXIgLSBmcm9tLnllYXI7XG4gICAgfVxuXG4gICAgLyoqXG4gICAgICogTm9ybWFsaXplcyB5ZWFyIGJ5IGNsYW1waW5nIGl0IGJldHdlZW4gbWluIGFuZCBtYXggeWVhcnNcbiAgICAgKi9cbiAgICBwdWJsaWMgc3RhdGljIG5vcm1hbGl6ZVllYXJQYXJ0KHllYXI6IG51bWJlcik6IG51bWJlciB7XG4gICAgICAgIHJldHVybiB0dWlOb3JtYWxpemVUb0ludE51bWJlcih5ZWFyLCBNSU5fWUVBUiwgTUFYX1lFQVIpO1xuICAgIH1cblxuICAgIHB1YmxpYyBnZXQgZm9ybWF0dGVkWWVhcigpOiBzdHJpbmcge1xuICAgICAgICByZXR1cm4gU3RyaW5nKHRoaXMueWVhcikucGFkU3RhcnQoNCwgJzAnKTtcbiAgICB9XG5cbiAgICBwdWJsaWMgZ2V0IGlzTGVhcFllYXIoKTogYm9vbGVhbiB7XG4gICAgICAgIHJldHVybiBUdWlZZWFyLmlzTGVhcFllYXIodGhpcy55ZWFyKTtcbiAgICB9XG5cbiAgICAvKipcbiAgICAgKiBSZXR1cm5zIGFtb3VudCBvZiBsZWFwIHllYXJzIGZyb20geWVhciAwIHRvIGN1cnJlbnRcbiAgICAgKi9cbiAgICBwdWJsaWMgZ2V0IGFic29sdXRlTGVhcFllYXJzKCk6IG51bWJlciB7XG4gICAgICAgIHJldHVybiBUdWlZZWFyLmdldEFic29sdXRlTGVhcFllYXJzKHRoaXMueWVhcik7XG4gICAgfVxuXG4gICAgLyoqXG4gICAgICogUGFzc2VkIHllYXIgaXMgYWZ0ZXIgY3VycmVudFxuICAgICAqL1xuICAgIHB1YmxpYyB5ZWFyQmVmb3JlKHt5ZWFyfTogVHVpWWVhcik6IGJvb2xlYW4ge1xuICAgICAgICByZXR1cm4gdGhpcy55ZWFyIDwgeWVhcjtcbiAgICB9XG5cbiAgICAvKipcbiAgICAgKiBQYXNzZWQgeWVhciBpcyB0aGUgc2FtZSBvciBhZnRlciBjdXJyZW50XG4gICAgICovXG4gICAgcHVibGljIHllYXJTYW1lT3JCZWZvcmUoe3llYXJ9OiBUdWlZZWFyKTogYm9vbGVhbiB7XG4gICAgICAgIHJldHVybiB0aGlzLnllYXIgPD0geWVhcjtcbiAgICB9XG5cbiAgICAvKipcbiAgICAgKiBQYXNzZWQgeWVhciBpcyB0aGUgc2FtZSBhcyBjdXJyZW50XG4gICAgICovXG4gICAgcHVibGljIHllYXJTYW1lKHt5ZWFyfTogVHVpWWVhcik6IGJvb2xlYW4ge1xuICAgICAgICByZXR1cm4gdGhpcy55ZWFyID09PSB5ZWFyO1xuICAgIH1cblxuICAgIC8qKlxuICAgICAqIFBhc3NlZCB5ZWFyIGlzIGVpdGhlciB0aGUgc2FtZSBvZiBiZWZvcmUgdGhlIGN1cnJlbnRcbiAgICAgKi9cbiAgICBwdWJsaWMgeWVhclNhbWVPckFmdGVyKHt5ZWFyfTogVHVpWWVhcik6IGJvb2xlYW4ge1xuICAgICAgICByZXR1cm4gdGhpcy55ZWFyID49IHllYXI7XG4gICAgfVxuXG4gICAgLyoqXG4gICAgICogUGFzc2VkIHllYXIgaXMgYmVmb3JlIGN1cnJlbnRcbiAgICAgKi9cbiAgICBwdWJsaWMgeWVhckFmdGVyKHt5ZWFyfTogVHVpWWVhcik6IGJvb2xlYW4ge1xuICAgICAgICByZXR1cm4gdGhpcy55ZWFyID4geWVhcjtcbiAgICB9XG5cbiAgICAvKipcbiAgICAgKiBJbW11dGFibHkgb2Zmc2V0cyB5ZWFyXG4gICAgICovXG4gICAgcHVibGljIGFwcGVuZCh7eWVhciA9IDB9OiBUdWlZZWFyTGlrZSk6IFR1aVllYXIge1xuICAgICAgICBuZ0Rldk1vZGUgJiYgY29uc29sZS5hc3NlcnQoTnVtYmVyLmlzSW50ZWdlcih5ZWFyKSk7XG5cbiAgICAgICAgY29uc3QgcmVzdWx0WWVhciA9IHRoaXMueWVhciArIHllYXI7XG5cbiAgICAgICAgbmdEZXZNb2RlICYmIGNvbnNvbGUuYXNzZXJ0KFR1aVllYXIuaXNWYWxpZFllYXIocmVzdWx0WWVhcikpO1xuXG4gICAgICAgIHJldHVybiBuZXcgVHVpWWVhcihyZXN1bHRZZWFyKTtcbiAgICB9XG5cbiAgICBwdWJsaWMgdG9TdHJpbmcoKTogc3RyaW5nIHtcbiAgICAgICAgcmV0dXJuIHRoaXMuZm9ybWF0dGVkWWVhcjtcbiAgICB9XG5cbiAgICBwdWJsaWMgdmFsdWVPZigpOiBudW1iZXIge1xuICAgICAgICByZXR1cm4gdGhpcy55ZWFyO1xuICAgIH1cblxuICAgIC8qKlxuICAgICAqIFJldHVybnMgdGhlIHByaW1pdGl2ZSB2YWx1ZSBvZiB0aGUgZ2l2ZW4gRGF0ZSBvYmplY3QuXG4gICAgICogRGVwZW5kaW5nIG9uIHRoZSBhcmd1bWVudCwgdGhlIG1ldGhvZCBjYW4gcmV0dXJuIGVpdGhlciBhIHN0cmluZyBvciBhIG51bWJlci5cbiAgICAgKiBAc2VlIGh0dHBzOi8vZGV2ZWxvcGVyLm1vemlsbGEub3JnL2VuLVVTL2RvY3MvV2ViL0phdmFTY3JpcHQvUmVmZXJlbmNlL0dsb2JhbF9PYmplY3RzL0RhdGUvQEB0b1ByaW1pdGl2ZVxuICAgICAqL1xuICAgIHB1YmxpYyBbU3ltYm9sLnRvUHJpbWl0aXZlXShoaW50OiBzdHJpbmcpOiBudW1iZXIgfCBzdHJpbmcge1xuICAgICAgICByZXR1cm4gRGF0ZS5wcm90b3R5cGVbU3ltYm9sLnRvUHJpbWl0aXZlXS5jYWxsKHRoaXMsIGhpbnQpO1xuICAgIH1cblxuICAgIHB1YmxpYyB0b0pTT04oKTogc3RyaW5nIHtcbiAgICAgICAgcmV0dXJuIHRoaXMuZm9ybWF0dGVkWWVhcjtcbiAgICB9XG59XG4iXX0=