/// <reference types="@taiga-ui/tsconfig/ng-dev-mode" />
import { tuiInRange, tuiNormalizeToIntNumber } from '@taiga-ui/cdk/utils/math';
import { DATE_FILLER_LENGTH } from './date-fillers';
import { MIN_DAY, MONTHS_IN_YEAR } from './date-time';
import { TuiDayOfWeek } from './day-of-week';
import { TuiMonth } from './month';
import { TuiMonthNumber } from './month-number';
import { TuiYear } from './year';
/**
 * Immutable date object, consisting of day, month and year
 */
export class TuiDay extends TuiMonth {
    constructor(year, month, day) {
        super(year, month);
        this.day = day;
        ngDevMode && console.assert(TuiDay.isValidDay(year, month, day));
    }
    /**
     * Creates {@link TuiDay} from native {@link Date} based on local time zone
     */
    static fromLocalNativeDate(date) {
        return new TuiDay(date.getFullYear(), date.getMonth(), date.getDate());
    }
    /**
     * Creates {@link TuiDay} from native {@link Date} using UTC
     */
    static fromUtcNativeDate(date) {
        return new TuiDay(date.getUTCFullYear(), date.getUTCMonth(), date.getUTCDate());
    }
    /**
     * Check validity of year, month and day
     *
     * @param year
     * @param month
     * @param day
     * @return boolean validity
     */
    static isValidDay(year, month, day) {
        return (TuiMonth.isValidMonth(year, month) &&
            Number.isInteger(day) &&
            tuiInRange(day, MIN_DAY, TuiMonth.getMonthDaysCount(month, TuiYear.isLeapYear(year)) + 1));
    }
    /**
     * Current day based on local time zone
     */
    static currentLocal() {
        const nativeDate = new Date();
        const year = nativeDate.getFullYear();
        const month = nativeDate.getMonth();
        const day = nativeDate.getDate();
        return new TuiDay(year, month, day);
    }
    /**
     * Returns current day based on UTC
     */
    static currentUtc() {
        const nativeDate = new Date();
        const year = nativeDate.getUTCFullYear();
        const month = nativeDate.getUTCMonth();
        const day = nativeDate.getUTCDate();
        return new TuiDay(year, month, day);
    }
    /**
     * Calculates {@link TuiDay} normalizing year, month and day. {@link NaN} is turned into minimal value.
     *
     * @param year any year value, including invalid
     * @param month any month value, including invalid (months start with 0)
     * @param day any day value, including invalid
     * @return normalized date
     */
    static normalizeOf(year, month, day) {
        const normalizedYear = TuiYear.normalizeYearPart(year);
        const normalizedMonth = TuiMonth.normalizeMonthPart(month);
        const normalizedDay = TuiDay.normalizeDayPart(day, normalizedMonth, normalizedYear);
        return new TuiDay(normalizedYear, normalizedMonth, normalizedDay);
    }
    static lengthBetween(from, to) {
        return Math.round((to.toLocalNativeDate().getTime() - from.toLocalNativeDate().getTime()) /
            (1000 * 60 * 60 * 24));
    }
    static parseRawDateString(date, dateMode = 'DMY') {
        ngDevMode &&
            console.assert(date.length === DATE_FILLER_LENGTH, '[parseRawDateString]: wrong date string length');
        switch (dateMode) {
            case 'MDY':
                return {
                    day: parseInt(date.slice(3, 5), 10),
                    month: parseInt(date.slice(0, 2), 10) - 1,
                    year: parseInt(date.slice(6, 10), 10),
                };
            case 'YMD':
                return {
                    day: parseInt(date.slice(8, 10), 10),
                    month: parseInt(date.slice(5, 7), 10) - 1,
                    year: parseInt(date.slice(0, 4), 10),
                };
            case 'DMY':
            default:
                return {
                    day: parseInt(date.slice(0, 2), 10),
                    month: parseInt(date.slice(3, 5), 10) - 1,
                    year: parseInt(date.slice(6, 10), 10),
                };
        }
    }
    // TODO: Move month and year related code corresponding classes
    /**
     * Parsing a string with date with normalization
     *
     * @param rawDate date string
     * @param dateMode date format of the date string (DMY | MDY | YMD)
     * @return normalized date
     */
    static normalizeParse(rawDate, dateMode = 'DMY') {
        const { day, month, year } = this.parseRawDateString(rawDate, dateMode);
        return TuiDay.normalizeOf(year, month, day);
    }
    /**
     * Parsing a date stringified in a toJSON format
     * @param yearMonthDayString date string in format of YYYY-MM-DD
     * @return date
     * @throws exceptions if any part of the date is invalid
     */
    static jsonParse(yearMonthDayString) {
        const { day, month, year } = this.parseRawDateString(yearMonthDayString, 'YMD');
        if (!TuiMonth.isValidMonth(year, month) ||
            !Number.isInteger(day) ||
            !tuiInRange(day, MIN_DAY, TuiMonth.getMonthDaysCount(month, TuiYear.isLeapYear(year)) + 1)) {
            throw new TuiInvalidDayException(year, month, day);
        }
        return new TuiDay(year, month, day);
    }
    static normalizeDayPart(day, month, year) {
        ngDevMode && console.assert(TuiMonth.isValidMonth(year, month));
        const monthDaysCount = TuiMonth.getMonthDaysCount(month, TuiYear.isLeapYear(year));
        return tuiNormalizeToIntNumber(day, 1, monthDaysCount);
    }
    get formattedDayPart() {
        return String(this.day).padStart(2, '0');
    }
    get isWeekend() {
        const dayOfWeek = this.dayOfWeek(false);
        return dayOfWeek === TuiDayOfWeek.Saturday || dayOfWeek === TuiDayOfWeek.Sunday;
    }
    /**
     * Returns day of week
     *
     * @param startFromMonday whether week starts from Monday and not from Sunday
     * @return day of week (from 0 to 6)
     */
    dayOfWeek(startFromMonday = true) {
        const dayOfWeek = startFromMonday
            ? this.toLocalNativeDate().getDay() - 1
            : this.toLocalNativeDate().getDay();
        return dayOfWeek < 0 ? 6 : dayOfWeek;
    }
    /**
     * Passed date is after current
     */
    dayBefore(another) {
        return (this.monthBefore(another) ||
            (this.monthSame(another) && this.day < another.day));
    }
    /**
     * Passed date is after or equals to current
     */
    daySameOrBefore(another) {
        return (this.monthBefore(another) ||
            (this.monthSame(another) && this.day <= another.day));
    }
    /**
     * Passed date is the same as current
     */
    daySame(another) {
        return this.monthSame(another) && this.day === another.day;
    }
    /**
     * Passed date is either before or the same as current
     */
    daySameOrAfter(another) {
        return (this.monthAfter(another) ||
            (this.monthSame(another) && this.day >= another.day));
    }
    /**
     * Passed date is before current
     */
    dayAfter(another) {
        return (this.monthAfter(another) ||
            (this.monthSame(another) && this.day > another.day));
    }
    /**
     * Clamping date between two limits
     *
     * @param min
     * @param max
     * @return clamped date
     */
    dayLimit(min, max) {
        if (min !== null && this.dayBefore(min)) {
            return min;
        }
        if (max !== null && this.dayAfter(max)) {
            return max;
        }
        return this;
    }
    /**
     * Immutably alters current day by passed offset
     *
     * If resulting month has more days than original one, date is rounded to the maximum day
     * in the resulting month. Offset of days will be calculated based on the resulted year and month
     * to not interfere with parent classes methods
     *
     * @param offset
     * @return new date object as a result of offsetting current
     */
    append({ year = 0, month = 0, day = 0 }) {
        const totalMonths = (this.year + year) * MONTHS_IN_YEAR + this.month + month;
        let years = Math.floor(totalMonths / MONTHS_IN_YEAR);
        let months = totalMonths % MONTHS_IN_YEAR;
        let days = Math.min(this.day, TuiMonth.getMonthDaysCount(months, TuiYear.isLeapYear(years))) + day;
        while (days > TuiMonth.getMonthDaysCount(months, TuiYear.isLeapYear(years))) {
            days -= TuiMonth.getMonthDaysCount(months, TuiYear.isLeapYear(years));
            if (months === TuiMonthNumber.December) {
                years++;
                months = TuiMonthNumber.January;
            }
            else {
                months++;
            }
        }
        while (days < MIN_DAY) {
            if (months === TuiMonthNumber.January) {
                years--;
                months = TuiMonthNumber.December;
            }
            else {
                months--;
            }
            days += TuiMonth.getMonthDaysCount(months, TuiYear.isLeapYear(years));
        }
        return new TuiDay(years, months, days);
    }
    /**
     * Returns formatted whole date
     */
    getFormattedDay(dateFormat, separator) {
        ngDevMode &&
            console.assert(separator.length === 1, 'Separator should consist of only 1 symbol');
        const dd = this.formattedDayPart;
        const mm = this.formattedMonthPart;
        const yyyy = this.formattedYear;
        switch (dateFormat) {
            case 'MDY':
                return `${mm}${separator}${dd}${separator}${yyyy}`;
            case 'YMD':
                return `${yyyy}${separator}${mm}${separator}${dd}`;
            case 'DMY':
            default:
                return `${dd}${separator}${mm}${separator}${yyyy}`;
        }
    }
    toString(dateFormat = 'DMY', separator = '.') {
        return this.getFormattedDay(dateFormat, separator);
    }
    toJSON() {
        return `${super.toJSON()}-${this.formattedDayPart}`;
    }
    /**
     * Returns native {@link Date} based on local time zone
     */
    toLocalNativeDate() {
        return new Date(this.year, this.month, this.day);
    }
    /**
     * Returns native {@link Date} based on UTC
     */
    toUtcNativeDate() {
        return new Date(Date.UTC(this.year, this.month, this.day));
    }
}
export class TuiInvalidDayException extends Error {
    constructor(year, month, day) {
        super(ngDevMode ? `Invalid day: ${year}-${month}-${day}` : '');
    }
}
//# sourceMappingURL=data:application/json;base64,eyJ2ZXJzaW9uIjozLCJmaWxlIjoiZGF5LmpzIiwic291cmNlUm9vdCI6IiIsInNvdXJjZXMiOlsiLi4vLi4vLi4vLi4vcHJvamVjdHMvY2RrL2RhdGUtdGltZS9kYXkudHMiXSwibmFtZXMiOltdLCJtYXBwaW5ncyI6IkFBQUEsd0RBQXdEO0FBRXhELE9BQU8sRUFBQyxVQUFVLEVBQUUsdUJBQXVCLEVBQUMsTUFBTSwwQkFBMEIsQ0FBQztBQUU3RSxPQUFPLEVBQUMsa0JBQWtCLEVBQUMsTUFBTSxnQkFBZ0IsQ0FBQztBQUNsRCxPQUFPLEVBQUMsT0FBTyxFQUFFLGNBQWMsRUFBQyxNQUFNLGFBQWEsQ0FBQztBQUNwRCxPQUFPLEVBQUMsWUFBWSxFQUFDLE1BQU0sZUFBZSxDQUFDO0FBQzNDLE9BQU8sRUFBQyxRQUFRLEVBQUMsTUFBTSxTQUFTLENBQUM7QUFDakMsT0FBTyxFQUFDLGNBQWMsRUFBQyxNQUFNLGdCQUFnQixDQUFDO0FBRTlDLE9BQU8sRUFBQyxPQUFPLEVBQUMsTUFBTSxRQUFRLENBQUM7QUFFL0I7O0dBRUc7QUFDSCxNQUFNLE9BQU8sTUFBTyxTQUFRLFFBQVE7SUFDaEMsWUFDSSxJQUFZLEVBQ1osS0FBYSxFQUNHLEdBQVc7UUFFM0IsS0FBSyxDQUFDLElBQUksRUFBRSxLQUFLLENBQUMsQ0FBQztRQUZILFFBQUcsR0FBSCxHQUFHLENBQVE7UUFHM0IsU0FBUyxJQUFJLE9BQU8sQ0FBQyxNQUFNLENBQUMsTUFBTSxDQUFDLFVBQVUsQ0FBQyxJQUFJLEVBQUUsS0FBSyxFQUFFLEdBQUcsQ0FBQyxDQUFDLENBQUM7SUFDckUsQ0FBQztJQUVEOztPQUVHO0lBQ0ksTUFBTSxDQUFDLG1CQUFtQixDQUFDLElBQVU7UUFDeEMsT0FBTyxJQUFJLE1BQU0sQ0FBQyxJQUFJLENBQUMsV0FBVyxFQUFFLEVBQUUsSUFBSSxDQUFDLFFBQVEsRUFBRSxFQUFFLElBQUksQ0FBQyxPQUFPLEVBQUUsQ0FBQyxDQUFDO0lBQzNFLENBQUM7SUFFRDs7T0FFRztJQUNJLE1BQU0sQ0FBQyxpQkFBaUIsQ0FB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QUM7SUFFRDs7T0FFRztJQUNhLGlCQUFpQjtRQUM3QixPQUFPLElBQUksSUFBSSxDQUFDLElBQUksQ0FBQyxJQUFJLEVBQUUsSUFBSSxDQUFDLEtBQUssRUFBRSxJQUFJLENBQUMsR0FBRyxDQUFDLENBQUM7SUFDckQsQ0FBQztJQUVEOztPQUVHO0lBQ2EsZUFBZTtRQUMzQixPQUFPLElBQUksSUFBSSxDQUFDLElBQUksQ0FBQyxHQUFHLENBQUMsSUFBSSxDQUFDLElBQUksRUFBRSxJQUFJLENBQUMsS0FBSyxFQUFFLElBQUksQ0FBQyxHQUFHLENBQUMsQ0FBQyxDQUFDO0lBQy9ELENBQUM7Q0FDSjtBQUVELE1BQU0sT0FBTyxzQkFBdUIsU0FBUSxLQUFLO0lBQzdDLFlBQVksSUFBWSxFQUFFLEtBQWEsRUFBRSxHQUFXO1FBQ2hELEtBQUssQ0FBQyxTQUFTLENBQUMsQ0FBQyxDQUFDLGdCQUFnQixJQUFJLElBQUksS0FBSyxJQUFJLEdBQUcsRUFBRSxDQUFDLENBQUMsQ0FBQyxFQUFFLENBQUMsQ0FBQztJQUNuRSxDQUFDO0NBQ0oiLCJzb3VyY2VzQ29udGVudCI6WyIvLy8gPHJlZmVyZW5jZSB0eXBlcz1cIkB0YWlnYS11aS90c2NvbmZpZy9uZy1kZXYtbW9kZVwiIC8+XG5cbmltcG9ydCB7dHVpSW5SYW5nZSwgdHVpTm9ybWFsaXplVG9JbnROdW1iZXJ9IGZyb20gJ0B0YWlnYS11aS9jZGsvdXRpbHMvbWF0aCc7XG5cbmltcG9ydCB7REFURV9GSUxMRVJfTEVOR1RIfSBmcm9tICcuL2RhdGUtZmlsbGVycyc7XG5pbXBvcnQge01JTl9EQVksIE1PTlRIU19JTl9ZRUFSfSBmcm9tICcuL2RhdGUtdGltZSc7XG5pbXBvcnQge1R1aURheU9mV2Vla30gZnJvbSAnLi9kYXktb2Ytd2Vlayc7XG5pbXBvcnQge1R1aU1vbnRofSBmcm9tICcuL21vbnRoJztcbmltcG9ydCB7VHVpTW9udGhOdW1iZXJ9IGZyb20gJy4vbW9udGgtbnVtYmVyJztcbmltcG9ydCB0eXBlIHtUdWlEYXRlTW9kZSwgVHVpRGF5TGlrZX0gZnJvbSAnLi90eXBlcyc7XG5pbXBvcnQge1R1aVllYXJ9IGZyb20gJy4veWVhcic7XG5cbi8qKlxuICogSW1tdXRhYmxlIGRhdGUgb2JqZWN0LCBjb25zaXN0aW5nIG9mIGRheSwgbW9udGggYW5kIHllYXJcbiAqL1xuZXhwb3J0IGNsYXNzIFR1aURheSBleHRlbmRzIFR1aU1vbnRoIHtcbiAgICBjb25zdHJ1Y3RvcihcbiAgICAgICAgeWVhcjogbnVtYmVyLFxuICAgICAgICBtb250aDogbnVtYmVyLFxuICAgICAgICBwdWJsaWMgcmVhZG9ubHkgZGF5OiBudW1iZXIsXG4gICAgKSB7XG4gICAgICAgIHN1cGVyKHllYXIsIG1vbnRoKTtcbiAgICAgICAgbmdEZXZNb2RlICYmIGNvbnNvbGUuYXNzZXJ0KFR1aURheS5pc1ZhbGlkRGF5KHllYXIsIG1vbnRoLCBkYXkpKTtcbiAgICB9XG5cbiAgICAvKipcbiAgICAgKiBDcmVhdGVzIHtAbGluayBUdWlEYXl9IGZyb20gbmF0aXZlIHtAbGluayBEYXRlfSBiYXNlZCBvbiBsb2NhbCB0aW1lIHpvbmVcbiAgICAgKi9cbiAgICBwdWJsaWMgc3RhdGljIGZyb21Mb2NhbE5hdGl2ZURhdGUoZGF0ZTogRGF0ZSk6IFR1aURheSB7XG4gICAgICAgIHJldHVybiBuZXcgVHVpRGF5KGRhdGUuZ2V0RnVsbFllYXIoKSwgZGF0ZS5nZXRNb250aCgpLCBkYXRlLmdldERhdGUoKSk7XG4gICAgfVxuXG4gICAgLyoqXG4gICAgICogQ3JlYXRlcyB7QGxpbmsgVHVpRGF5fSBmcm9tIG5hdGl2ZSB7QGxpbmsgRGF0ZX0gdXNpbmcgVVRDXG4gICAgICovXG4gICAgcHVibGljIHN0YXRpYyBmcm9tVXRjTmF0aXZlRGF0ZShkYXRlOiBEYXRlKTogVHVpRGF5IHtcbiAgICAgICAgcmV0dXJuIG5ldyBUdWlEYXkoZGF0ZS5nZXRVVENGdWxsWWVhcigpLCBkYXRlLmdldFVUQ01vbnRoKCksIGRhdGUuZ2V0VVRDRGF0ZSgpKTtcbiAgICB9XG5cbiAgICAvKipcbiAgICAgKiBDaGVjayB2YWxpZGl0eSBvZiB5ZWFyLCBtb250aCBhbmQgZGF5XG4gICAgICpcbiAgICAgKiBAcGFyYW0geWVhclxuICAgICAqIEBwYXJhbSBtb250aFxuICAgICAqIEBwYXJhbSBkYXlcbiAgICAgKiBAcmV0dXJuIGJvb2xlYW4gdmFsaWRpdHlcbiAgICAgKi9cbiAgICBwdWJsaWMgc3RhdGljIGlzVmFsaWREYXkoeWVhcjogbnVtYmVyLCBtb250aDogbnVtYmVyLCBkYXk6IG51bWJlcik6IGJvb2xlYW4ge1xuICAgICAgICByZXR1cm4gKFxuICAgICAgICAgICAgVHVpTW9udGguaXNWYWxpZE1vbnRoKHllYXIsIG1vbnRoKSAmJlxuICAgICAgICAgICAgTnVtYmVyLmlzSW50ZWdlcihkYXkpICYmXG4gICAgICAgICAgICB0dWlJblJhbmdlKFxuICAgICAgICAgICAgICAgIGRheSxcbiAgICAgICAgICAgICAgICBNSU5fREFZLFxuICAgICAgICAgICAgICAgIFR1aU1vbnRoLmdldE1vbnRoRGF5c0NvdW50KG1vbnRoLCBUdWlZZWFyLmlzTGVhcFllYXIoeWVhcikpICsgMSxcbiAgICAgICAgICAgIClcbiAgICAgICAgKTtcbiAgICB9XG5cbiAgICAvKipcbiAgICAgKiBDdXJyZW50IGRheSBiYXNlZCBvbiBsb2NhbCB0aW1lIHpvbmVcbiAgICAgKi9cbiAgICBwdWJsaWMgc3RhdGljIG92ZXJyaWRlIGN1cnJlbnRMb2NhbCgpOiBUdWlEYXkge1xuICAgICAgICBjb25zdCBuYXRpdmVEYXRlID0gbmV3IERhdGUoKTtcbiAgICAgICAgY29uc3QgeWVhciA9IG5hdGl2ZURhdGUuZ2V0RnVsbFllYXIoKTtcbiAgICAgICAgY29uc3QgbW9udGggPSBuYXRpdmVEYXRlLmdldE1vbnRoKCk7XG4gICAgICAgIGNvbnN0IGRheSA9IG5hdGl2ZURhdGUuZ2V0RGF0ZSgpO1xuXG4gICAgICAgIHJldHVybiBuZXcgVHVpRGF5KHllYXIsIG1vbnRoLCBkYXkpO1xuICAgIH1cblxuICAgIC8qKlxuICAgICAqIFJldHVybnMgY3VycmVudCBkYXkgYmFzZWQgb24gVVRDXG4gICAgICovXG4gICAgcHVibGljIHN0YXRpYyBvdmVycmlkZSBjdXJyZW50VXRjKCk6IFR1aURheSB7XG4gICAgICAgIGNvbnN0IG5hdGl2ZURhdGUgPSBuZXcgRGF0ZSgpO1xuICAgICAgICBjb25zdCB5ZWFyID0gbmF0aXZlRGF0ZS5nZXRVVENGdWxsWWVhcigpO1xuICAgICAgICBjb25zdCBtb250aCA9IG5hdGl2ZURhdGUuZ2V0VVRDTW9udGgoKTtcbiAgICAgICAgY29uc3QgZGF5ID0gbmF0aXZlRGF0ZS5nZXRVVENEYXRlKCk7XG5cbiAgICAgICAgcmV0dXJuIG5ldyBUdWlEYXkoeWVhciwgbW9udGgsIGRheSk7XG4gICAgfVxuXG4gICAgLyoqXG4gICAgICogQ2FsY3VsYXRlcyB7QGxpbmsgVHVpRGF5fSBub3JtYWxpemluZyB5ZWFyLCBtb250aCBhbmQgZGF5LiB7QGxpbmsgTmFOfSBpcyB0dXJuZWQgaW50byBtaW5pbWFsIHZhbHVlLlxuICAgICAqXG4gICAgICogQHBhcmFtIHllYXIgYW55IHllYXIgdmFsdWUsIGluY2x1ZGluZyBpbnZhbGlkXG4gICAgICogQHBhcmFtIG1vbnRoIGFueSBtb250aCB2YWx1ZSwgaW5jbHVkaW5nIGludmFsaWQgKG1vbnRocyBzdGFydCB3aXRoIDApXG4gICAgICogQHBhcmFtIGRheSBhbnkgZGF5IHZhbHVlLCBpbmNsdWRpbmcgaW52YWxpZFxuICAgICAqIEByZXR1cm4gbm9ybWFsaXplZCBkYXRlXG4gICAgICovXG4gICAgcHVibGljIHN0YXRpYyBub3JtYWxpemVPZih5ZWFyOiBudW1iZXIsIG1vbnRoOiBudW1iZXIsIGRheTogbnVtYmVyKTogVHVpRGF5IHtcbiAgICAgICAgY29uc3Qgbm9ybWFsaXplZFllYXIgPSBUdWlZZWFyLm5vcm1hbGl6ZVllYXJQYXJ0KHllYXIpO1xuICAgICAgICBjb25zdCBub3JtYWxpemVkTW9udGggPSBUdWlNb250aC5ub3JtYWxpemVNb250aFBhcnQobW9udGgpO1xuICAgICAgICBjb25zdCBub3JtYWxpemVkRGF5ID0gVHVpRGF5Lm5vcm1hbGl6ZURheVBhcnQoXG4gICAgICAgICAgICBkYXksXG4gICAgICAgICAgICBub3JtYWxpemVkTW9udGgsXG4gICAgICAgICAgICBub3JtYWxpemVkWWVhcixcbiAgICAgICAgKTtcblxuICAgICAgICByZXR1cm4gbmV3IFR1aURheShub3JtYWxpemVkWWVhciwgbm9ybWFsaXplZE1vbnRoLCBub3JtYWxpemVkRGF5KTtcbiAgICB9XG5cbiAgICBwdWJsaWMgc3RhdGljIG92ZXJyaWRlIGxlbmd0aEJldHdlZW4oZnJvbTogVHVpRGF5LCB0bzogVHVpRGF5KTogbnVtYmVyIHtcbiAgICAgICAgcmV0dXJuIE1hdGgucm91bmQoXG4gICAgICAgICAgICAodG8udG9Mb2NhbE5hdGl2ZURhdGUoKS5nZXRUaW1lKCkgLSBmcm9tLnRvTG9jYWxOYXRpdmVEYXRlKCkuZ2V0VGltZSgpKSAvXG4gICAgICAgICAgICAgICAgKDEwMDAgKiA2MCAqIDYwICogMjQpLFxuICAgICAgICApO1xuICAgIH1cblxuICAgIHB1YmxpYyBzdGF0aWMgcGFyc2VSYXdEYXRlU3RyaW5nKFxuICAgICAgICBkYXRlOiBzdHJpbmcsXG4gICAgICAgIGRhdGVNb2RlOiBUdWlEYXRlTW9kZSA9ICdETVknLFxuICAgICk6IHtkYXk6IG51bWJlcjsgbW9udGg6IG51bWJlcjsgeWVhcjogbnVtYmVyfSB7XG4gICAgICAgIG5nRGV2TW9kZSAmJlxuICAgICAgICAgICAgY29uc29sZS5hc3NlcnQoXG4gICAgICAgICAgICAgICAgZGF0ZS5sZW5ndGggPT09IERBVEVfRklMTEVSX0xFTkdUSCxcbiAgICAgICAgICAgICAgICAnW3BhcnNlUmF3RGF0ZVN0cmluZ106IHdyb25nIGRhdGUgc3RyaW5nIGxlbmd0aCcsXG4gICAgICAgICAgICApO1xuXG4gICAgICAgIHN3aXRjaCAoZGF0ZU1vZGUpIHtcbiAgICAgICAgICAgIGNhc2UgJ01EWSc6XG4gICAgICAgICAgICAgICAgcmV0dXJuIHtcbiAgICAgICAgICAgICAgICAgICAgZGF5OiBwYXJzZUludChkYXRlLnNsaWNlKDMsIDUpLCAxMCksXG4gICAgICAgICAgICAgICAgICAgIG1vbnRoOiBwYXJzZUludChkYXRlLnNsaWNlKDAsIDIpLCAxMCkgLSAxLFxuICAgICAgICAgICAgICAgICAgICB5ZWFyOiBwYXJzZUludChkYXRlLnNsaWNlKDYsIDEwKSwgMTApLFxuICAgICAgICAgICAgICAgIH07XG5cbiAgICAgICAgICAgIGNhc2UgJ1lNRCc6XG4gICAgICAgICAgICAgICAgcmV0dXJuIHtcbiAgICAgICAgICAgICAgICAgICAgZGF5OiBwYXJzZUludChkYXRlLnNsaWNlKDgsIDEwKSwgMTApLFxuICAgICAgICAgICAgICAgICAgICBtb250aDogcGFyc2VJbnQoZGF0ZS5zbGljZSg1LCA3KSwgMTApIC0gMSxcbiAgICAgICAgICAgICAgICAgICAgeWVhcjogcGFyc2VJbnQoZGF0ZS5zbGljZSgwLCA0KSwgMTApLFxuICAgICAgICAgICAgICAgIH07XG5cbiAgICAgICAgICAgIGNhc2UgJ0RNWSc6XG4gICAgICAgICAgICBkZWZhdWx0OlxuICAgICAgICAgICAgICAgIHJldHVybiB7XG4gICAgICAgICAgICAgICAgICAgIGRheTogcGFyc2VJbnQoZGF0ZS5zbGljZSgwLCAyKSwgMTApLFxuICAgICAgICAgICAgICAgICAgICBtb250aDogcGFyc2VJbnQoZGF0ZS5zbGljZSgzLCA1KSwgMTApIC0gMSxcbiAgICAgICAgICAgICAgICAgICAgeWVhcjogcGFyc2VJbnQoZGF0ZS5zbGljZSg2LCAxMCksIDEwKSxcbiAgICAgICAgICAgICAgICB9O1xuICAgICAgICB9XG4gICAgfVxuXG4gICAgLy8gVE9ETzogTW92ZSBtb250aCBhbmQgeWVhciByZWxhdGVkIGNvZGUgY29ycmVzcG9uZGluZyBjbGFzc2VzXG4gICAgLyoqXG4gICAgICogUGFyc2luZyBhIHN0cmluZyB3aXRoIGRhdGUgd2l0aCBub3JtYWxpemF0aW9uXG4gICAgICpcbiAgICAgKiBAcGFyYW0gcmF3RGF0ZSBkYXRlIHN0cmluZ1xuICAgICAqIEBwYXJhbSBkYXRlTW9kZSBkYXRlIGZvcm1hdCBvZiB0aGUgZGF0ZSBzdHJpbmcgKERNWSB8IE1EWSB8IFlNRClcbiAgICAgKiBAcmV0dXJuIG5vcm1hbGl6ZWQgZGF0ZVxuICAgICAqL1xuICAgIHB1YmxpYyBzdGF0aWMgbm9ybWFsaXplUGFyc2UocmF3RGF0ZTogc3RyaW5nLCBkYXRlTW9kZTogVHVpRGF0ZU1vZGUgPSAnRE1ZJyk6IFR1aURheSB7XG4gICAgICAgIGNvbnN0IHtkYXksIG1vbnRoLCB5ZWFyfSA9IHRoaXMucGFyc2VSYXdEYXRlU3RyaW5nKHJhd0RhdGUsIGRhdGVNb2RlKTtcblxuICAgICAgICByZXR1cm4gVHVpRGF5Lm5vcm1hbGl6ZU9mKHllYXIsIG1vbnRoLCBkYXkpO1xuICAgIH1cblxuICAgIC8qKlxuICAgICAqIFBhcnNpbmcgYSBkYXRlIHN0cmluZ2lmaWVkIGluIGEgdG9KU09OIGZvcm1hdFxuICAgICAqIEBwYXJhbSB5ZWFyTW9udGhEYXlTdHJpbmcgZGF0ZSBzdHJpbmcgaW4gZm9ybWF0IG9mIFlZWVktTU0tRERcbiAgICAgKiBAcmV0dXJuIGRhdGVcbiAgICAgKiBAdGhyb3dzIGV4Y2VwdGlvbnMgaWYgYW55IHBhcnQgb2YgdGhlIGRhdGUgaXMgaW52YWxpZFxuICAgICAqL1xuICAgIHB1YmxpYyBzdGF0aWMganNvblBhcnNlKHllYXJNb250aERheVN0cmluZzogc3RyaW5nKTogVHVpRGF5IHtcbiAgICAgICAgY29uc3Qge2RheSwgbW9udGgsIHllYXJ9ID0gdGhpcy5wYXJzZVJhd0RhdGVTdHJpbmcoeWVhck1vbnRoRGF5U3RyaW5nLCAnWU1EJyk7XG5cbiAgICAgICAgaWYgKFxuICAgICAgICAgICAgIVR1aU1vbnRoLmlzVmFsaWRNb250aCh5ZWFyLCBtb250aCkgfHxcbiAgICAgICAgICAgICFOdW1iZXIuaXNJbnRlZ2VyKGRheSkgfHxcbiAgICAgICAgICAgICF0dWlJblJhbmdlKFxuICAgICAgICAgICAgICAgIGRheSxcbiAgICAgICAgICAgICAgICBNSU5fREFZLFxuICAgICAgICAgICAgICAgIFR1aU1vbnRoLmdldE1vbnRoRGF5c0NvdW50KG1vbnRoLCBUdWlZZWFyLmlzTGVhcFllYXIoeWVhcikpICsgMSxcbiAgICAgICAgICAgIClcbiAgICAgICAgKSB7XG4gICAgICAgICAgICB0aHJvdyBuZXcgVHVpSW52YWxpZERheUV4Y2VwdGlvbih5ZWFyLCBtb250aCwgZGF5KTtcbiAgICAgICAgfVxuXG4gICAgICAgIHJldHVybiBuZXcgVHVpRGF5KHllYXIsIG1vbnRoLCBkYXkpO1xuICAgIH1cblxuICAgIHB1YmxpYyBzdGF0aWMgbm9ybWFsaXplRGF5UGFydChkYXk6IG51bWJlciwgbW9udGg6IG51bWJlciwgeWVhcjogbnVtYmVyKTogbnVtYmVyIHtcbiAgICAgICAgbmdEZXZNb2RlICYmIGNvbnNvbGUuYXNzZXJ0KFR1aU1vbnRoLmlzVmFsaWRNb250aCh5ZWFyLCBtb250aCkpO1xuXG4gICAgICAgIGNvbnN0IG1vbnRoRGF5c0NvdW50ID0gVHVpTW9udGguZ2V0TW9udGhEYXlzQ291bnQoXG4gICAgICAgICAgICBtb250aCxcbiAgICAgICAgICAgIFR1aVllYXIuaXNMZWFwWWVhcih5ZWFyKSxcbiAgICAgICAgKTtcblxuICAgICAgICByZXR1cm4gdHVpTm9ybWFsaXplVG9JbnROdW1iZXIoZGF5LCAxLCBtb250aERheXNDb3VudCk7XG4gICAgfVxuXG4gICAgcHVibGljIGdldCBmb3JtYXR0ZWREYXlQYXJ0KCk6IHN0cmluZyB7XG4gICAgICAgIHJldHVybiBTdHJpbmcodGhpcy5kYXkpLnBhZFN0YXJ0KDIsICcwJyk7XG4gICAgfVxuXG4gICAgcHVibGljIGdldCBpc1dlZWtlbmQoKTogYm9vbGVhbiB7XG4gICAgICAgIGNvbnN0IGRheU9mV2VlayA9IHRoaXMuZGF5T2ZXZWVrKGZhbHNlKTtcblxuICAgICAgICByZXR1cm4gZGF5T2ZXZWVrID09PSBUdWlEYXlPZldlZWsuU2F0dXJkYXkgfHwgZGF5T2ZXZWVrID09PSBUdWlEYXlPZldlZWsuU3VuZGF5O1xuICAgIH1cblxuICAgIC8qKlxuICAgICAqIFJldHVybnMgZGF5IG9mIHdlZWtcbiAgICAgKlxuICAgICAqIEBwYXJhbSBzdGFydEZyb21Nb25kYXkgd2hldGhlciB3ZWVrIHN0YXJ0cyBmcm9tIE1vbmRheSBhbmQgbm90IGZyb20gU3VuZGF5XG4gICAgICogQHJldHVybiBkYXkgb2Ygd2VlayAoZnJvbSAwIHRvIDYpXG4gICAgICovXG4gICAgcHVibGljIGRheU9mV2VlayhzdGFydEZyb21Nb25kYXkgPSB0cnVlKTogbnVtYmVyIHtcbiAgICAgICAgY29uc3QgZGF5T2ZXZWVrID0gc3RhcnRGcm9tTW9uZGF5XG4gICAgICAgICAgICA/IHRoaXMudG9Mb2NhbE5hdGl2ZURhdGUoKS5nZXREYXkoKSAtIDFcbiAgICAgICAgICAgIDogdGhpcy50b0xvY2FsTmF0aXZlRGF0ZSgpLmdldERheSgpO1xuXG4gICAgICAgIHJldHVybiBkYXlPZldlZWsgPCAwID8gNiA6IGRheU9mV2VlaztcbiAgICB9XG5cbiAgICAvKipcbiAgICAgKiBQYXNzZWQgZGF0ZSBpcyBhZnRlciBjdXJyZW50XG4gICAgICovXG4gICAgcHVibGljIGRheUJlZm9yZShhbm90aGVyOiBUdWlEYXkpOiBib29sZWFuIHtcbiAgICAgICAgcmV0dXJuIChcbiAgICAgICAgICAgIHRoaXMubW9udGhCZWZvcmUoYW5vdGhlcikgfHxcbiAgICAgICAgICAgICh0aGlzLm1vbnRoU2FtZShhbm90aGVyKSAmJiB0aGlzLmRheSA8IGFub3RoZXIuZGF5KVxuICAgICAgICApO1xuICAgIH1cblxuICAgIC8qKlxuICAgICAqIFBhc3NlZCBkYXRlIGlzIGFmdGVyIG9yIGVxdWFscyB0byBjdXJyZW50XG4gICAgICovXG4gICAgcHVibGljIGRheVNhbWVPckJlZm9yZShhbm90aGVyOiBUdWlEYXkpOiBib29sZWFuIHtcbiAgICAgICAgcmV0dXJuIChcbiAgICAgICAgICAgIHRoaXMubW9udGhCZWZvcmUoYW5vdGhlcikgfHxcbiAgICAgICAgICAgICh0aGlzLm1vbnRoU2FtZShhbm90aGVyKSAmJiB0aGlzLmRheSA8PSBhbm90aGVyLmRheSlcbiAgICAgICAgKTtcbiAgICB9XG5cbiAgICAvKipcbiAgICAgKiBQYXNzZWQgZGF0ZSBpcyB0aGUgc2FtZSBhcyBjdXJyZW50XG4gICAgICovXG4gICAgcHVibGljIGRheVNhbWUoYW5vdGhlcjogVHVpRGF5KTogYm9vbGVhbiB7XG4gICAgICAgIHJldHVybiB0aGlzLm1vbnRoU2FtZShhbm90aGVyKSAmJiB0aGlzLmRheSA9PT0gYW5vdGhlci5kYXk7XG4gICAgfVxuXG4gICAgLyoqXG4gICAgICogUGFzc2VkIGRhdGUgaXMgZWl0aGVyIGJlZm9yZSBvciB0aGUgc2FtZSBhcyBjdXJyZW50XG4gICAgICovXG4gICAgcHVibGljIGRheVNhbWVPckFmdGVyKGFub3RoZXI6IFR1aURheSk6IGJvb2xlYW4ge1xuICAgICAgICByZXR1cm4gKFxuICAgICAgICAgICAgdGhpcy5tb250aEFmdGVyKGFub3RoZXIpIHx8XG4gICAgICAgICAgICAodGhpcy5tb250aFNhbWUoYW5vdGhlcikgJiYgdGhpcy5kYXkgPj0gYW5vdGhlci5kYXkpXG4gICAgICAgICk7XG4gICAgfVxuXG4gICAgLyoqXG4gICAgICogUGFzc2VkIGRhdGUgaXMgYmVmb3JlIGN1cnJlbnRcbiAgICAgKi9cbiAgICBwdWJsaWMgZGF5QWZ0ZXIoYW5vdGhlcjogVHVpRGF5KTogYm9vbGVhbiB7XG4gICAgICAgIHJldHVybiAoXG4gICAgICAgICAgICB0aGlzLm1vbnRoQWZ0ZXIoYW5vdGhlcikgfHxcbiAgICAgICAgICAgICh0aGlzLm1vbnRoU2FtZShhbm90aGVyKSAmJiB0aGlzLmRheSA+IGFub3RoZXIuZGF5KVxuICAgICAgICApO1xuICAgIH1cblxuICAgIC8qKlxuICAgICAqIENsYW1waW5nIGRhdGUgYmV0d2VlbiB0d28gbGltaXRzXG4gICAgICpcbiAgICAgKiBAcGFyYW0gbWluXG4gICAgICogQHBhcmFtIG1heFxuICAgICAqIEByZXR1cm4gY2xhbXBlZCBkYXRlXG4gICAgICovXG4gICAgcHVibGljIGRheUxpbWl0KG1pbjogVHVpRGF5IHwgbnVsbCwgbWF4OiBUdWlEYXkgfCBudWxsKTogVHVpRGF5IHtcbiAgICAgICAgaWYgKG1pbiAhPT0gbnVsbCAmJiB0aGlzLmRheUJlZm9yZShtaW4pKSB7XG4gICAgICAgICAgICByZXR1cm4gbWluO1xuICAgICAgICB9XG5cbiAgICAgICAgaWYgKG1heCAhPT0gbnVsbCAmJiB0aGlzLmRheUFmdGVyKG1heCkpIHtcbiAgICAgICAgICAgIHJldHVybiBtYXg7XG4gICAgICAgIH1cblxuICAgICAgICByZXR1cm4gdGhpcztcbiAgICB9XG5cbiAgICAvKipcbiAgICAgKiBJbW11dGFibHkgYWx0ZXJzIGN1cnJlbnQgZGF5IGJ5IHBhc3NlZCBvZmZzZXRcbiAgICAgKlxuICAgICAqIElmIHJlc3VsdGluZyBtb250aCBoYXMgbW9yZSBkYXlzIHRoYW4gb3JpZ2luYWwgb25lLCBkYXRlIGlzIHJvdW5kZWQgdG8gdGhlIG1heGltdW0gZGF5XG4gICAgICogaW4gdGhlIHJlc3VsdGluZyBtb250aC4gT2Zmc2V0IG9mIGRheXMgd2lsbCBiZSBjYWxjdWxhdGVkIGJhc2VkIG9uIHRoZSByZXN1bHRlZCB5ZWFyIGFuZCBtb250aFxuICAgICAqIHRvIG5vdCBpbnRlcmZlcmUgd2l0aCBwYXJlbnQgY2xhc3NlcyBtZXRob2RzXG4gICAgICpcbiAgICAgKiBAcGFyYW0gb2Zmc2V0XG4gICAgICogQHJldHVybiBuZXcgZGF0ZSBvYmplY3QgYXMgYSByZXN1bHQgb2Ygb2Zmc2V0dGluZyBjdXJyZW50XG4gICAgICovXG4gICAgcHVibGljIG92ZXJyaWRlIGFwcGVuZCh7eWVhciA9IDAsIG1vbnRoID0gMCwgZGF5ID0gMH06IFR1aURheUxpa2UpOiBUdWlEYXkge1xuICAgICAgICBjb25zdCB0b3RhbE1vbnRocyA9ICh0aGlzLnllYXIgKyB5ZWFyKSAqIE1PTlRIU19JTl9ZRUFSICsgdGhpcy5tb250aCArIG1vbnRoO1xuICAgICAgICBsZXQgeWVhcnMgPSBNYXRoLmZsb29yKHRvdGFsTW9udGhzIC8gTU9OVEhTX0lOX1lFQVIpO1xuICAgICAgICBsZXQgbW9udGhzID0gdG90YWxNb250aHMgJSBNT05USFNfSU5fWUVBUjtcblxuICAgICAgICBsZXQgZGF5cyA9XG4gICAgICAgICAgICBNYXRoLm1pbihcbiAgICAgICAgICAgICAgICB0aGlzLmRheSxcbiAgICAgICAgICAgICAgICBUdWlNb250aC5nZXRNb250aERheXNDb3VudChtb250aHMsIFR1aVllYXIuaXNMZWFwWWVhcih5ZWFycykpLFxuICAgICAgICAgICAgKSArIGRheTtcblxuICAgICAgICB3aGlsZSAoZGF5cyA+IFR1aU1vbnRoLmdldE1vbnRoRGF5c0NvdW50KG1vbnRocywgVHVpWWVhci5pc0xlYXBZZWFyKHllYXJzKSkpIHtcbiAgICAgICAgICAgIGRheXMgLT0gVHVpTW9udGguZ2V0TW9udGhEYXlzQ291bnQobW9udGhzLCBUdWlZZWFyLmlzTGVhcFllYXIoeWVhcnMpKTtcblxuICAgICAgICAgICAgaWYgKG1vbnRocyA9PT0gVHVpTW9udGhOdW1iZXIuRGVjZW1iZXIpIHtcbiAgICAgICAgICAgICAgICB5ZWFycysrO1xuICAgICAgICAgICAgICAgIG1vbnRocyA9IFR1aU1vbnRoTnVtYmVyLkphbnVhcnk7XG4gICAgICAgICAgICB9IGVsc2Uge1xuICAgICAgICAgICAgICAgIG1vbnRocysrO1xuICAgICAgICAgICAgfVxuICAgICAgICB9XG5cbiAgICAgICAgd2hpbGUgKGRheXMgPCBNSU5fREFZKSB7XG4gICAgICAgICAgICBpZiAobW9udGhzID09PSBUdWlNb250aE51bWJlci5KYW51YXJ5KSB7XG4gICAgICAgICAgICAgICAgeWVhcnMtLTtcbiAgICAgICAgICAgICAgICBtb250aHMgPSBUdWlNb250aE51bWJlci5EZWNlbWJlcjtcbiAgICAgICAgICAgIH0gZWxzZSB7XG4gICAgICAgICAgICAgICAgbW9udGhzLS07XG4gICAgICAgICAgICB9XG5cbiAgICAgICAgICAgIGRheXMgKz0gVHVpTW9udGguZ2V0TW9udGhEYXlzQ291bnQobW9udGhzLCBUdWlZZWFyLmlzTGVhcFllYXIoeWVhcnMpKTtcbiAgICAgICAgfVxuXG4gICAgICAgIHJldHVybiBuZXcgVHVpRGF5KHllYXJzLCBtb250aHMsIGRheXMpO1xuICAgIH1cblxuICAgIC8qKlxuICAgICAqIFJldHVybnMgZm9ybWF0dGVkIHdob2xlIGRhdGVcbiAgICAgKi9cbiAgICBwdWJsaWMgZ2V0Rm9ybWF0dGVkRGF5KGRhdGVGb3JtYXQ6IFR1aURhdGVNb2RlLCBzZXBhcmF0b3I6IHN0cmluZyk6IHN0cmluZyB7XG4gICAgICAgIG5nRGV2TW9kZSAmJlxuICAgICAgICAgICAgY29uc29sZS5hc3NlcnQoXG4gICAgICAgICAgICAgICAgc2VwYXJhdG9yLmxlbmd0aCA9PT0gMSxcbiAgICAgICAgICAgICAgICAnU2VwYXJhdG9yIHNob3VsZCBjb25zaXN0IG9mIG9ubHkgMSBzeW1ib2wnLFxuICAgICAgICAgICAgKTtcblxuICAgICAgICBjb25zdCBkZCA9IHRoaXMuZm9ybWF0dGVkRGF5UGFydDtcbiAgICAgICAgY29uc3QgbW0gPSB0aGlzLmZvcm1hdHRlZE1vbnRoUGFydDtcbiAgICAgICAgY29uc3QgeXl5eSA9IHRoaXMuZm9ybWF0dGVkWWVhcjtcblxuICAgICAgICBzd2l0Y2ggKGRhdGVGb3JtYXQpIHtcbiAgICAgICAgICAgIGNhc2UgJ01EWSc6XG4gICAgICAgICAgICAgICAgcmV0dXJuIGAke21tfSR7c2VwYXJhdG9yfSR7ZGR9JHtzZXBhcmF0b3J9JHt5eXl5fWA7XG4gICAgICAgICAgICBjYXNlICdZTUQnOlxuICAgICAgICAgICAgICAgIHJldHVybiBgJHt5eXl5fSR7c2VwYXJhdG9yfSR7bW19JHtzZXBhcmF0b3J9JHtkZH1gO1xuICAgICAgICAgICAgY2FzZSAnRE1ZJzpcbiAgICAgICAgICAgIGRlZmF1bHQ6XG4gICAgICAgICAgICAgICAgcmV0dXJuIGAke2RkfSR7c2VwYXJhdG9yfSR7bW19JHtzZXBhcmF0b3J9JHt5eXl5fWA7XG4gICAgICAgIH1cbiAgICB9XG5cbiAgICBwdWJsaWMgb3ZlcnJpZGUgdG9TdHJpbmcoZGF0ZUZvcm1hdDogVHVpRGF0ZU1vZGUgPSAnRE1ZJywgc2VwYXJhdG9yID0gJy4nKTogc3RyaW5nIHtcbiAgICAgICAgcmV0dXJuIHRoaXMuZ2V0Rm9ybWF0dGVkRGF5KGRhdGVGb3JtYXQsIHNlcGFyYXRvcik7XG4gICAgfVxuXG4gICAgcHVibGljIG92ZXJyaWRlIHRvSlNPTigpOiBzdHJpbmcge1xuICAgICAgICByZXR1cm4gYCR7c3VwZXIudG9KU09OKCl9LSR7dGhpcy5mb3JtYXR0ZWREYXlQYXJ0fWA7XG4gICAgfVxuXG4gICAgLyoqXG4gICAgICogUmV0dXJucyBuYXRpdmUge0BsaW5rIERhdGV9IGJhc2VkIG9uIGxvY2FsIHRpbWUgem9uZVxuICAgICAqL1xuICAgIHB1YmxpYyBvdmVycmlkZSB0b0xvY2FsTmF0aXZlRGF0ZSgpOiBEYXRlIHtcbiAgICAgICAgcmV0dXJuIG5ldyBEYXRlKHRoaXMueWVhciwgdGhpcy5tb250aCwgdGhpcy5kYXkpO1xuICAgIH1cblxuICAgIC8qKlxuICAgICAqIFJldHVybnMgbmF0aXZlIHtAbGluayBEYXRlfSBiYXNlZCBvbiBVVENcbiAgICAgKi9cbiAgICBwdWJsaWMgb3ZlcnJpZGUgdG9VdGNOYXRpdmVEYXRlKCk6IERhdGUge1xuICAgICAgICByZXR1cm4gbmV3IERhdGUoRGF0ZS5VVEModGhpcy55ZWFyLCB0aGlzLm1vbnRoLCB0aGlzLmRheSkpO1xuICAgIH1cbn1cblxuZXhwb3J0IGNsYXNzIFR1aUludmFsaWREYXlFeGNlcHRpb24gZXh0ZW5kcyBFcnJvciB7XG4gICAgY29uc3RydWN0b3IoeWVhcjogbnVtYmVyLCBtb250aDogbnVtYmVyLCBkYXk6IG51bWJlcikge1xuICAgICAgICBzdXBlcihuZ0Rldk1vZGUgPyBgSW52YWxpZCBkYXk6ICR7eWVhcn0tJHttb250aH0tJHtkYXl9YCA6ICcnKTtcbiAgICB9XG59XG4iXX0=