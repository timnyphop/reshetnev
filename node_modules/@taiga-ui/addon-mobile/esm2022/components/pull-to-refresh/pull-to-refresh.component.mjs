import { AsyncPipe, NgStyle } from '@angular/common';
import { ChangeDetectionStrategy, Component, inject, Input, Output } from '@angular/core';
import { takeUntilDestroyed } from '@angular/core/rxjs-interop';
import { tuiScrollFrom, tuiZonefree } from '@taiga-ui/cdk/observables';
import { TUI_IS_IOS } from '@taiga-ui/cdk/tokens';
import { tuiPx } from '@taiga-ui/cdk/utils/miscellaneous';
import { TUI_SCROLL_REF } from '@taiga-ui/core/tokens';
import { PolymorpheusOutlet, PolymorpheusTemplate } from '@taiga-ui/polymorpheus';
import { distinctUntilChanged, filter, map, startWith } from 'rxjs';
import { TUI_PULL_TO_REFRESH_COMPONENT, TUI_PULL_TO_REFRESH_THRESHOLD, } from './pull-to-refresh.providers';
import { MICRO_OFFSET, TuiPullToRefreshService } from './pull-to-refresh.service';
import * as i0 from "@angular/core";
class TuiPullToRefresh {
    constructor() {
        this.isIOS = inject(TUI_IS_IOS);
        this.threshold = inject(TUI_PULL_TO_REFRESH_THRESHOLD);
        this.pulling$ = inject(TuiPullToRefreshService);
        this.component = inject(TUI_PULL_TO_REFRESH_COMPONENT);
        this.dropped$ = this.pulling$.pipe(map((distance) => distance <= MICRO_OFFSET || distance === this.threshold), distinctUntilChanged());
        this.styleHandler = this.isIOS
            ? (distance) => ({ top: tuiPx(distance / 2) })
            : () => null;
        this.pulled = inject(TuiPullToRefreshService).pipe(filter((distance) => distance === this.threshold));
        if (!this.component) {
            return; // Ensure scrolling down is impossible while pulling
        }
        const el = inject(TUI_SCROLL_REF).nativeElement;
        tuiScrollFrom(el)
            .pipe(startWith(null), tuiZonefree(), takeUntilDestroyed())
            .subscribe(() => {
            if (el.scrollTop) {
                el.style.touchAction = '';
            }
            else {
                el.style.touchAction = 'pan-down';
            }
        });
    }
    static { this.ɵfac = i0.ɵɵngDeclareFactory({ minVersion: "12.0.0", version: "16.2.12", ngImport: i0, type: TuiPullToRefresh, deps: [], target: i0.ɵɵFactoryTarget.Component }); }
    static { this.ɵcmp = i0.ɵɵngDeclareComponent({ minVersion: "14.0.0", version: "16.2.12", type: TuiPullToRefresh, isStandalone: true, selector: "tui-pull-to-refresh", inputs: { styleHandler: "styleHandler" }, outputs: { pulled: "pulled" }, providers: [TuiPullToRefreshService], ngImport: i0, template: "<ng-container *polymorpheusOutlet=\"component; context: {$implicit: (pulling$ | async) || 0}\" />\n\n<div\n    [class.t-drop]=\"dropped$ | async\"\n    [ngStyle]=\"styleHandler((pulling$ | async) || 0)\"\n    [style.position]=\"'relative'\"\n>\n    <ng-content />\n</div>\n", styles: [".t-drop{transition:all var(--tui-duration) cubic-bezier(.4,0,.2,1)}\n"], dependencies: [{ kind: "pipe", type: AsyncPipe, name: "async" }, { kind: "directive", type: NgStyle, selector: "[ngStyle]", inputs: ["ngStyle"] }, { kind: "directive", type: PolymorpheusOutlet, selector: "[polymorpheusOutlet]", inputs: ["polymorpheusOutlet", "polymorpheusOutletContext"] }], changeDetection: i0.ChangeDetectionStrategy.OnPush }); }
}
export { TuiPullToRefresh };
i0.ɵɵngDeclareClassMetadata({ minVersion: "12.0.0", version: "16.2.12", ngImport: i0, type: TuiPullToRefresh, decorators: [{
            type: Component,
            args: [{ standalone: true, selector: 'tui-pull-to-refresh', imports: [AsyncPipe, NgStyle, PolymorpheusOutlet, PolymorpheusTemplate], changeDetection: ChangeDetectionStrategy.OnPush, providers: [TuiPullToRefreshService], template: "<ng-container *polymorpheusOutlet=\"component; context: {$implicit: (pulling$ | async) || 0}\" />\n\n<div\n    [class.t-drop]=\"dropped$ | async\"\n    [ngStyle]=\"styleHandler((pulling$ | async) || 0)\"\n    [style.position]=\"'relative'\"\n>\n    <ng-content />\n</div>\n", styles: [".t-drop{transition:all var(--tui-duration) cubic-bezier(.4,0,.2,1)}\n"] }]
        }], ctorParameters: function () { return []; }, propDecorators: { styleHandler: [{
                type: Input
            }], pulled: [{
                type: Output
            }] } });
//# sourceMappingURL=data:application/json;base64,eyJ2ZXJzaW9uIjozLCJmaWxlIjoicHVsbC10by1yZWZyZXNoLmNvbXBvbmVudC5qcyIsInNvdXJjZVJvb3QiOiIiLCJzb3VyY2VzIjpbIi4uLy4uLy4uLy4uLy4uL3Byb2plY3RzL2FkZG9uLW1vYmlsZS9jb21wb25lbnRzL3B1bGwtdG8tcmVmcmVzaC9wdWxsLXRvLXJlZnJlc2guY29tcG9uZW50LnRzIiwiLi4vLi4vLi4vLi4vLi4vcHJvamVjdHMvYWRkb24tbW9iaWxlL2NvbXBvbmVudHMvcHVsbC10by1yZWZyZXNoL3B1bGwtdG8tcmVmcmVzaC50ZW1wbGF0ZS5odG1sIl0sIm5hbWVzIjpbXSwibWFwcGluZ3MiOiJBQUFBLE9BQU8sRUFBQyxTQUFTLEVBQUUsT0FBTyxFQUFDLE1BQU0saUJBQWlCLENBQUM7QUFDbkQsT0FBTyxFQUFDLHVCQUF1QixFQUFFLFNBQVMsRUFBRSxNQUFNLEVBQUUsS0FBSyxFQUFFLE1BQU0sRUFBQyxNQUFNLGVBQWUsQ0FBQztBQUN4RixPQUFPLEVBQUMsa0JBQWtCLEVBQUMsTUFBTSw0QkFBNEIsQ0FBQztBQUM5RCxPQUFPLEVBQUMsYUFBYSxFQUFFLFdBQVcsRUFBQyxNQUFNLDJCQUEyQixDQUFDO0FBQ3JFLE9BQU8sRUFBQyxVQUFVLEVBQUMsTUFBTSxzQkFBc0IsQ0FBQztBQUVoRCxPQUFPLEVBQUMsS0FBSyxFQUFDLE1BQU0sbUNBQW1DLENBQUM7QUFDeEQsT0FBTyxFQUFDLGNBQWMsRUFBQyxNQUFNLHVCQUF1QixDQUFDO0FBRXJELE9BQU8sRUFBQyxrQkFBa0IsRUFBRSxvQkFBb0IsRUFBQyxNQUFNLHdCQUF3QixDQUFDO0FBRWhGLE9BQU8sRUFBQyxvQkFBb0IsRUFBRSxNQUFNLEVBQUUsR0FBRyxFQUFFLFNBQVMsRUFBQyxNQUFNLE1BQU0sQ0FBQztBQUVsRSxPQUFPLEVBQ0gsNkJBQTZCLEVBQzdCLDZCQUE2QixHQUNoQyxNQUFNLDZCQUE2QixDQUFDO0FBQ3JDLE9BQU8sRUFBQyxZQUFZLEVBQUUsdUJBQXVCLEVBQUMsTUFBTSwyQkFBMkIsQ0FBQzs7QUFFaEYsTUFTYSxnQkFBZ0I7SUF3QnpCO1FBdkJpQixVQUFLLEdBQUcsTUFBTSxDQUFDLFVBQVUsQ0FBQyxDQUFDO1FBQzNCLGNBQVMsR0FBRyxNQUFNLENBQUMsNkJBQTZCLENBQUMsQ0FBQztRQUVoRCxhQUFRLEdBQUcsTUFBTSxDQUFDLHVCQUF1QixDQUFDLENBQUM7UUFDM0MsY0FBUyxHQUFHLE1BQU0sQ0FDakMsNkJBQTZCLENBQ2hDLENBQUM7UUFFaUIsYUFBUSxHQUF3QixJQUFJLENBQUMsUUFBUSxDQUFDLElBQUksQ0FDakUsR0FBRyxDQUFDLENBQUMsUUFBUSxFQUFFLEVBQUUsQ0FBQyxRQUFRLElBQUksWUFBWSxJQUFJLFFBQVEsS0FBSyxJQUFJLENBQUMsU0FBUyxDQUFDLEVBQzFFLG9CQUFvQixFQUFFLENBQ3pCLENBQUM7UUFHSyxpQkFBWSxHQUFtRCxJQUFJLENBQUMsS0FBSztZQUM1RSxDQUFDLENBQUMsQ0FBQyxRQUFRLEVBQUUsRUFBRSxDQUFDLENBQUMsRUFBQyxHQUFHLEVBQUUsS0FBSyxDQUFDLFFBQVEsR0FBRyxDQUFDLENBQUMsRUFBQyxDQUFDO1lBQzVDLENBQUMsQ0FBQyxHQUFHLEVBQUUsQ0FBQyxJQUFJLENBQUM7UUFHRCxXQUFNLEdBQXdCLE1BQU0sQ0FBQyx1QkFBdUIsQ0FBQyxDQUFDLElBQUksQ0FDOUUsTUFBTSxDQUFDLENBQUMsUUFBUSxFQUFFLEVBQUUsQ0FBQyxRQUFRLEtBQUssSUFBSSxDQUFDLFNBQVMsQ0FBQyxDQUNwRCxDQUFDO1FBR0UsSUFBSSxDQUFDLElBQUksQ0FBQyxTQUFTLEVBQUU7WUFDakIsT0FBTyxDQUFDLG9EQUFvRDtTQUMvRDtRQUVELE1BQU0sRUFBRSxHQUFnQixNQUFNLENBQUMsY0FBYyxDQUFDLENBQUMsYUFBYSxDQUFDO1FBRTdELGFBQWEsQ0FBQyxFQUFFLENBQUM7YUFDWixJQUFJLENBQUMsU0FBUyxDQUFDLElBQUksQ0FBQyxFQUFFLFdBQVcsRUFBRSxFQUFFLGtCQUFrQixFQUFFLENBQUM7YUFDMUQsU0FBUyxDQUFDLEdBQUcsRUFBRTtZQUNaLElBQUksRUFBRSxDQUFDLFNBQVMsRUFBRTtnQkFDZCxFQUFFLENBQUMsS0FBSyxDQUFDLFdBQVcsR0FBRyxFQUFFLENBQUM7YUFDN0I7aUJBQU07Z0JBQ0gsRUFBRSxDQUFDLEtBQUssQ0FBQyxXQUFXLEdBQUcsVUFBVSxDQUFDO2FBQ3JDO1FBQ0wsQ0FBQyxDQUFDLENBQUM7SUFDWCxDQUFDOytHQXhDUSxnQkFBZ0I7bUdBQWhCLGdCQUFnQiwySUFGZCxDQUFDLHVCQUF1QixDQUFDLDBCQzFCeEMsbVJBU0EsMEhEYWMsU0FBUyw4Q0FBRSxPQUFPLDJFQUFFLGtCQUFrQjs7U0FNdkMsZ0JBQWdCOzRGQUFoQixnQkFBZ0I7a0JBVDVCLFNBQVM7aUNBQ00sSUFBSSxZQUNOLHFCQUFxQixXQUN0QixDQUFDLFNBQVMsRUFBRSxPQUFPLEVBQUUsa0JBQWtCLEVBQUUsb0JBQW9CLENBQUMsbUJBR3RELHVCQUF1QixDQUFDLE1BQU0sYUFDcEMsQ0FBQyx1QkFBdUIsQ0FBQzswRUFpQjdCLFlBQVk7c0JBRGxCLEtBQUs7Z0JBTVUsTUFBTTtzQkFEckIsTUFBTSIsInNvdXJjZXNDb250ZW50IjpbImltcG9ydCB7QXN5bmNQaXBlLCBOZ1N0eWxlfSBmcm9tICdAYW5ndWxhci9jb21tb24nO1xuaW1wb3J0IHtDaGFuZ2VEZXRlY3Rpb25TdHJhdGVneSwgQ29tcG9uZW50LCBpbmplY3QsIElucHV0LCBPdXRwdXR9IGZyb20gJ0Bhbmd1bGFyL2NvcmUnO1xuaW1wb3J0IHt0YWtlVW50aWxEZXN0cm95ZWR9IGZyb20gJ0Bhbmd1bGFyL2NvcmUvcnhqcy1pbnRlcm9wJztcbmltcG9ydCB7dHVpU2Nyb2xsRnJvbSwgdHVpWm9uZWZyZWV9IGZyb20gJ0B0YWlnYS11aS9jZGsvb2JzZXJ2YWJsZXMnO1xuaW1wb3J0IHtUVUlfSVNfSU9TfSBmcm9tICdAdGFpZ2EtdWkvY2RrL3Rva2Vucyc7XG5pbXBvcnQgdHlwZSB7VHVpQ29udGV4dCwgVHVpSGFuZGxlcn0gZnJvbSAnQHRhaWdhLXVpL2Nkay90eXBlcyc7XG5pbXBvcnQge3R1aVB4fSBmcm9tICdAdGFpZ2EtdWkvY2RrL3V0aWxzL21pc2NlbGxhbmVvdXMnO1xuaW1wb3J0IHtUVUlfU0NST0xMX1JFRn0gZnJvbSAnQHRhaWdhLXVpL2NvcmUvdG9rZW5zJztcbmltcG9ydCB0eXBlIHtQb2x5bW9ycGhldXNDb250ZW50fSBmcm9tICdAdGFpZ2EtdWkvcG9seW1vcnBoZXVzJztcbmltcG9ydCB7UG9seW1vcnBoZXVzT3V0bGV0LCBQb2x5bW9ycGhldXNUZW1wbGF0ZX0gZnJvbSAnQHRhaWdhLXVpL3BvbHltb3JwaGV1cyc7XG5pbXBvcnQgdHlwZSB7T2JzZXJ2YWJsZX0gZnJvbSAncnhqcyc7XG5pbXBvcnQge2Rpc3RpbmN0VW50aWxDaGFuZ2VkLCBmaWx0ZXIsIG1hcCwgc3RhcnRXaXRofSBmcm9tICdyeGpzJztcblxuaW1wb3J0IHtcbiAgICBUVUlfUFVMTF9UT19SRUZSRVNIX0NPTVBPTkVOVCxcbiAgICBUVUlfUFVMTF9UT19SRUZSRVNIX1RIUkVTSE9MRCxcbn0gZnJvbSAnLi9wdWxsLXRvLXJlZnJlc2gucHJvdmlkZXJzJztcbmltcG9ydCB7TUlDUk9fT0ZGU0VULCBUdWlQdWxsVG9SZWZyZXNoU2VydmljZX0gZnJvbSAnLi9wdWxsLXRvLXJlZnJlc2guc2VydmljZSc7XG5cbkBDb21wb25lbnQoe1xuICAgIHN0YW5kYWxvbmU6IHRydWUsXG4gICAgc2VsZWN0b3I6ICd0dWktcHVsbC10by1yZWZyZXNoJyxcbiAgICBpbXBvcnRzOiBbQXN5bmNQaXBlLCBOZ1N0eWxlLCBQb2x5bW9ycGhldXNPdXRsZXQsIFBvbHltb3JwaGV1c1RlbXBsYXRlXSxcbiAgICB0ZW1wbGF0ZVVybDogJy4vcHVsbC10by1yZWZyZXNoLnRlbXBsYXRlLmh0bWwnLFxuICAgIHN0eWxlVXJsczogWycuL3B1bGwtdG8tcmVmcmVzaC5zdHlsZS5sZXNzJ10sXG4gICAgY2hhbmdlRGV0ZWN0aW9uOiBDaGFuZ2VEZXRlY3Rpb25TdHJhdGVneS5PblB1c2gsXG4gICAgcHJvdmlkZXJzOiBbVHVpUHVsbFRvUmVmcmVzaFNlcnZpY2VdLFxufSlcbmV4cG9ydCBjbGFzcyBUdWlQdWxsVG9SZWZyZXNoIHtcbiAgICBwcml2YXRlIHJlYWRvbmx5IGlzSU9TID0gaW5qZWN0KFRVSV9JU19JT1MpO1xuICAgIHByaXZhdGUgcmVhZG9ubHkgdGhyZXNob2xkID0gaW5qZWN0KFRVSV9QVUxMX1RPX1JFRlJFU0hfVEhSRVNIT0xEKTtcblxuICAgIHByb3RlY3RlZCByZWFkb25seSBwdWxsaW5nJCA9IGluamVjdChUdWlQdWxsVG9SZWZyZXNoU2VydmljZSk7XG4gICAgcHJvdGVjdGVkIHJlYWRvbmx5IGNvbXBvbmVudCA9IGluamVjdDxQb2x5bW9ycGhldXNDb250ZW50PFR1aUNvbnRleHQ8bnVtYmVyPj4+KFxuICAgICAgICBUVUlfUFVMTF9UT19SRUZSRVNIX0NPTVBPTkVOVCxcbiAgICApO1xuXG4gICAgcHJvdGVjdGVkIHJlYWRvbmx5IGRyb3BwZWQkOiBPYnNlcnZhYmxlPGJvb2xlYW4+ID0gdGhpcy5wdWxsaW5nJC5waXBlKFxuICAgICAgICBtYXAoKGRpc3RhbmNlKSA9PiBkaXN0YW5jZSA8PSBNSUNST19PRkZTRVQgfHwgZGlzdGFuY2UgPT09IHRoaXMudGhyZXNob2xkKSxcbiAgICAgICAgZGlzdGluY3RVbnRpbENoYW5nZWQoKSxcbiAgICApO1xuXG4gICAgQElucHV0KClcbiAgICBwdWJsaWMgc3R5bGVIYW5kbGVyOiBUdWlIYW5kbGVyPG51bWJlciwgUmVjb3JkPHN0cmluZywgYW55PiB8IG51bGw+ID0gdGhpcy5pc0lPU1xuICAgICAgICA/IChkaXN0YW5jZSkgPT4gKHt0b3A6IHR1aVB4KGRpc3RhbmNlIC8gMil9KVxuICAgICAgICA6ICgpID0+IG51bGw7XG5cbiAgICBAT3V0cHV0KClcbiAgICBwdWJsaWMgcmVhZG9ubHkgcHVsbGVkOiBPYnNlcnZhYmxlPHVua25vd24+ID0gaW5qZWN0KFR1aVB1bGxUb1JlZnJlc2hTZXJ2aWNlKS5waXBlKFxuICAgICAgICBmaWx0ZXIoKGRpc3RhbmNlKSA9PiBkaXN0YW5jZSA9PT0gdGhpcy50aHJlc2hvbGQpLFxuICAgICk7XG5cbiAgICBjb25zdHJ1Y3RvcigpIHtcbiAgICAgICAgaWYgKCF0aGlzLmNvbXBvbmVudCkge1xuICAgICAgICAgICAgcmV0dXJuOyAvLyBFbnN1cmUgc2Nyb2xsaW5nIGRvd24gaXMgaW1wb3NzaWJsZSB3aGlsZSBwdWxsaW5nXG4gICAgICAgIH1cblxuICAgICAgICBjb25zdCBlbDogSFRNTEVsZW1lbnQgPSBpbmplY3QoVFVJX1NDUk9MTF9SRUYpLm5hdGl2ZUVsZW1lbnQ7XG5cbiAgICAgICAgdHVpU2Nyb2xsRnJvbShlbClcbiAgICAgICAgICAgIC5waXBlKHN0YXJ0V2l0aChudWxsKSwgdHVpWm9uZWZyZWUoKSwgdGFrZVVudGlsRGVzdHJveWVkKCkpXG4gICAgICAgICAgICAuc3Vic2NyaWJlKCgpID0+IHtcbiAgICAgICAgICAgICAgICBpZiAoZWwuc2Nyb2xsVG9wKSB7XG4gICAgICAgICAgICAgICAgICAgIGVsLnN0eWxlLnRvdWNoQWN0aW9uID0gJyc7XG4gICAgICAgICAgICAgICAgfSBlbHNlIHtcbiAgICAgICAgICAgICAgICAgICAgZWwuc3R5bGUudG91Y2hBY3Rpb24gPSAncGFuLWRvd24nO1xuICAgICAgICAgICAgICAgIH1cbiAgICAgICAgICAgIH0pO1xuICAgIH1cbn1cbiIsIjxuZy1jb250YWluZXIgKnBvbHltb3JwaGV1c091dGxldD1cImNvbXBvbmVudDsgY29udGV4dDogeyRpbXBsaWNpdDogKHB1bGxpbmckIHwgYXN5bmMpIHx8IDB9XCIgLz5cblxuPGRpdlxuICAgIFtjbGFzcy50LWRyb3BdPVwiZHJvcHBlZCQgfCBhc3luY1wiXG4gICAgW25nU3R5bGVdPVwic3R5bGVIYW5kbGVyKChwdWxsaW5nJCB8IGFzeW5jKSB8fCAwKVwiXG4gICAgW3N0eWxlLnBvc2l0aW9uXT1cIidyZWxhdGl2ZSdcIlxuPlxuICAgIDxuZy1jb250ZW50IC8+XG48L2Rpdj5cbiJdfQ==