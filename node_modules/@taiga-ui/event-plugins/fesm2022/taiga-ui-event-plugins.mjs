import { EVENT_MANAGER_PLUGINS } from '@angular/platform-browser';
import { DOCUMENT } from '@angular/common';
import * as i0 from '@angular/core';
import { InjectionToken, inject, Injectable } from '@angular/core';

class AbstractEventPlugin {
    supports(event) {
        return event.includes(this.modifier);
    }
    unwrap(event) {
        return event
            .split('.')
            .filter((v) => !this.modifier.includes(v))
            .join('.');
    }
}

const GLOBAL_HANDLER = new InjectionToken('[GLOBAL_HANDLER]: Global event target handler', {
    factory: () => {
        const document = inject(DOCUMENT);
        return (name) => name === 'body'
            ? document.body
            : document.defaultView[name] ||
                document.createElement('div');
    },
});
class GlobalEventPlugin extends AbstractEventPlugin {
    constructor() {
        super(...arguments);
        this.handler = inject(GLOBAL_HANDLER);
        this.modifier = '>';
    }
    addEventListener(_, event, handler) {
        return this.manager.addEventListener(this.handler(event.split('>')[0]), event.split('>')?.[1] ?? '', handler);
    }
    static { this.ɵfac = i0.ɵɵngDeclareFactory({ minVersion: "12.0.0", version: "16.2.12", ngImport: i0, type: GlobalEventPlugin, deps: null, target: i0.ɵɵFactoryTarget.Injectable }); }
    static { this.ɵprov = i0.ɵɵngDeclareInjectable({ minVersion: "12.0.0", version: "16.2.12", ngImport: i0, type: GlobalEventPlugin }); }
}
i0.ɵɵngDeclareClassMetadata({ minVersion: "12.0.0", version: "16.2.12", ngImport: i0, type: GlobalEventPlugin, decorators: [{
            type: Injectable
        }] });

class OptionsEventPlugin extends AbstractEventPlugin {
    constructor() {
        super(...arguments);
        this.modifier = 'capture.once.passive';
    }
    supports(event) {
        return event.includes('.') && !this.unwrap(event).includes('.');
    }
    addEventListener(element, event, handler) {
        element.addEventListener(this.unwrap(event), handler, {
            once: event.includes('.once'),
            passive: event.includes('.passive'),
            capture: event.includes('.capture'),
        });
        return () => element.removeEventListener(this.unwrap(event), handler, event.includes('.capture'));
    }
    static { this.ɵfac = i0.ɵɵngDeclareFactory({ minVersion: "12.0.0", version: "16.2.12", ngImport: i0, type: OptionsEventPlugin, deps: null, target: i0.ɵɵFactoryTarget.Injectable }); }
    static { this.ɵprov = i0.ɵɵngDeclareInjectable({ minVersion: "12.0.0", version: "16.2.12", ngImport: i0, type: OptionsEventPlugin }); }
}
i0.ɵɵngDeclareClassMetadata({ minVersion: "12.0.0", version: "16.2.12", ngImport: i0, type: OptionsEventPlugin, decorators: [{
            type: Injectable
        }] });

class PreventEventPlugin extends AbstractEventPlugin {
    constructor() {
        super(...arguments);
        this.modifier = '.prevent';
    }
    addEventListener(element, event, handler) {
        return this.manager.addEventListener(element, this.unwrap(event), (event) => {
            event.preventDefault();
            handler(event);
        });
    }
    static { this.ɵfac = i0.ɵɵngDeclareFactory({ minVersion: "12.0.0", version: "16.2.12", ngImport: i0, type: PreventEventPlugin, deps: null, target: i0.ɵɵFactoryTarget.Injectable }); }
    static { this.ɵprov = i0.ɵɵngDeclareInjectable({ minVersion: "12.0.0", version: "16.2.12", ngImport: i0, type: PreventEventPlugin }); }
}
i0.ɵɵngDeclareClassMetadata({ minVersion: "12.0.0", version: "16.2.12", ngImport: i0, type: PreventEventPlugin, decorators: [{
            type: Injectable
        }] });

class ResizePlugin extends AbstractEventPlugin {
    constructor() {
        super(...arguments);
        this.modifier = 'resize';
    }
    supports(event) {
        return event === 'resize';
    }
    addEventListener(element, event, handler) {
        if (typeof ResizeObserver === 'undefined' || !(element instanceof Element)) {
            element.addEventListener(event, handler);
            return () => element.removeEventListener(event, handler);
        }
        const observer = new ResizeObserver(handler);
        observer.observe(element);
        return () => observer.disconnect();
    }
    static { this.ɵfac = i0.ɵɵngDeclareFactory({ minVersion: "12.0.0", version: "16.2.12", ngImport: i0, type: ResizePlugin, deps: null, target: i0.ɵɵFactoryTarget.Injectable }); }
    static { this.ɵprov = i0.ɵɵngDeclareInjectable({ minVersion: "12.0.0", version: "16.2.12", ngImport: i0, type: ResizePlugin }); }
}
i0.ɵɵngDeclareClassMetadata({ minVersion: "12.0.0", version: "16.2.12", ngImport: i0, type: ResizePlugin, decorators: [{
            type: Injectable
        }] });

class SelfEventPlugin extends AbstractEventPlugin {
    constructor() {
        super(...arguments);
        this.modifier = '.self';
    }
    addEventListener(element, event, handler) {
        return this.manager.addEventListener(element, this.unwrap(event), (event) => {
            if (event.target === event.currentTarget) {
                handler(event);
            }
        });
    }
    static { this.ɵfac = i0.ɵɵngDeclareFactory({ minVersion: "12.0.0", version: "16.2.12", ngImport: i0, type: SelfEventPlugin, deps: null, target: i0.ɵɵFactoryTarget.Injectable }); }
    static { this.ɵprov = i0.ɵɵngDeclareInjectable({ minVersion: "12.0.0", version: "16.2.12", ngImport: i0, type: SelfEventPlugin }); }
}
i0.ɵɵngDeclareClassMetadata({ minVersion: "12.0.0", version: "16.2.12", ngImport: i0, type: SelfEventPlugin, decorators: [{
            type: Injectable
        }] });

class SilentEventPlugin extends AbstractEventPlugin {
    constructor() {
        super(...arguments);
        this.modifier = '.silent';
    }
    addEventListener(element, event, handler) {
        SilentEventPlugin.ngZone = this.manager.getZone();
        return SilentEventPlugin.ngZone.runOutsideAngular(() => this.manager.addEventListener(element, this.unwrap(event), handler));
    }
    static { this.ɵfac = i0.ɵɵngDeclareFactory({ minVersion: "12.0.0", version: "16.2.12", ngImport: i0, type: SilentEventPlugin, deps: null, target: i0.ɵɵFactoryTarget.Injectable }); }
    static { this.ɵprov = i0.ɵɵngDeclareInjectable({ minVersion: "12.0.0", version: "16.2.12", ngImport: i0, type: SilentEventPlugin }); }
}
i0.ɵɵngDeclareClassMetadata({ minVersion: "12.0.0", version: "16.2.12", ngImport: i0, type: SilentEventPlugin, decorators: [{
            type: Injectable
        }] });

class StopEventPlugin extends AbstractEventPlugin {
    constructor() {
        super(...arguments);
        this.modifier = '.stop';
    }
    addEventListener(element, event, handler) {
        return this.manager.addEventListener(element, this.unwrap(event), (event) => {
            event.stopPropagation();
            handler(event);
        });
    }
    static { this.ɵfac = i0.ɵɵngDeclareFactory({ minVersion: "12.0.0", version: "16.2.12", ngImport: i0, type: StopEventPlugin, deps: null, target: i0.ɵɵFactoryTarget.Injectable }); }
    static { this.ɵprov = i0.ɵɵngDeclareInjectable({ minVersion: "12.0.0", version: "16.2.12", ngImport: i0, type: StopEventPlugin }); }
}
i0.ɵɵngDeclareClassMetadata({ minVersion: "12.0.0", version: "16.2.12", ngImport: i0, type: StopEventPlugin, decorators: [{
            type: Injectable
        }] });

const PLUGINS = [
    SilentEventPlugin,
    GlobalEventPlugin,
    OptionsEventPlugin,
    PreventEventPlugin,
    ResizePlugin,
    SelfEventPlugin,
    StopEventPlugin,
];
const NG_EVENT_PLUGINS = PLUGINS.map((useClass) => ({
    provide: EVENT_MANAGER_PLUGINS,
    multi: true,
    useClass,
}));

function shouldCall(predicate) {
    return (_target, _key, desc) => {
        const { value } = desc;
        desc.value = function (...args) {
            if (!predicate.apply(this, args)) {
                return;
            }
            if (SilentEventPlugin.ngZone) {
                SilentEventPlugin.ngZone.run(() => value.apply(this, args));
            }
            else {
                value.apply(this, args);
            }
        };
    };
}

function asCallable(a) {
    return a;
}

/**
 * Generated bundle index. Do not edit.
 */

export { GLOBAL_HANDLER, GlobalEventPlugin, NG_EVENT_PLUGINS, OptionsEventPlugin, PreventEventPlugin, ResizePlugin, SilentEventPlugin, StopEventPlugin, asCallable, shouldCall };
//# sourceMappingURL=taiga-ui-event-plugins.mjs.map
