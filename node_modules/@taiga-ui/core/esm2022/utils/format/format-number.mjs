import { CHAR_HYPHEN } from '@taiga-ui/cdk/constants';
import { tuiRoundWith } from '@taiga-ui/cdk/utils/math';
import { TUI_DEFAULT_NUMBER_FORMAT, } from '@taiga-ui/core/tokens';
import { tuiGetFractionPartPadded } from './get-fractional-part-padded';
/**
 * Formats number adding a thousand separators and correct decimal separator
 * padding decimal part with zeroes to given length
 *
 * @param value the input number
 * @param settings See {@link TuiNumberFormatSettings}
 * @return the formatted string
 */
export function tuiFormatNumber(value, settings = {}) {
    const { precision, decimalSeparator, thousandSeparator, decimalMode, rounding } = {
        ...TUI_DEFAULT_NUMBER_FORMAT,
        decimalMode: 'always',
        precision: Infinity,
        ...settings,
    };
    const rounded = Number.isFinite(precision)
        ? tuiRoundWith({ value, precision, method: rounding })
        : value;
    const integerPartString = String(Math.floor(Math.abs(rounded)));
    let fractionPartPadded = tuiGetFractionPartPadded(rounded, precision);
    const hasFraction = Number(fractionPartPadded) > 0;
    if (Number.isFinite(precision)) {
        if (decimalMode === 'always' || (hasFraction && decimalMode === 'pad')) {
            const zeroPaddingSize = Math.max(precision - fractionPartPadded.length, 0);
            const zeroPartString = '0'.repeat(zeroPaddingSize);
            fractionPartPadded = `${fractionPartPadded}${zeroPartString}`;
        }
        else {
            fractionPartPadded = fractionPartPadded.replace(/0*$/, '');
        }
    }
    const remainder = integerPartString.length % 3;
    const sign = value < 0 ? CHAR_HYPHEN : '';
    let result = sign + integerPartString.charAt(0);
    for (let i = 1; i < integerPartString.length; i++) {
        if (i % 3 === remainder && integerPartString.length > 3) {
            result += thousandSeparator;
        }
        result += integerPartString.charAt(i);
    }
    return fractionPartPadded ? result + decimalSeparator + fractionPartPadded : result;
}
//# sourceMappingURL=data:application/json;base64,eyJ2ZXJzaW9uIjozLCJmaWxlIjoiZm9ybWF0LW51bWJlci5qcyIsInNvdXJjZVJvb3QiOiIiLCJzb3VyY2VzIjpbIi4uLy4uLy4uLy4uLy4uL3Byb2plY3RzL2NvcmUvdXRpbHMvZm9ybWF0L2Zvcm1hdC1udW1iZXIudHMiXSwibmFtZXMiOltdLCJtYXBwaW5ncyI6IkFBQUEsT0FBTyxFQUFDLFdBQVcsRUFBQyxNQUFNLHlCQUF5QixDQUFDO0FBQ3BELE9BQU8sRUFBQyxZQUFZLEVBQUMsTUFBTSwwQkFBMEIsQ0FBQztBQUN0RCxPQUFPLEVBQ0gseUJBQXlCLEdBRTVCLE1BQU0sdUJBQXVCLENBQUM7QUFFL0IsT0FBTyxFQUFDLHdCQUF3QixFQUFDLE1BQU0sOEJBQThCLENBQUM7QUFFdEU7Ozs7Ozs7R0FPRztBQUNILE1BQU0sVUFBVSxlQUFlLENBQzNCLEtBQWEsRUFDYixXQUE2QyxFQUFFO0lBRS9DLE1BQU0sRUFBQyxTQUFTLEVBQUUsZ0JBQWdCLEVBQUUsaUJBQWlCLEVBQUUsV0FBVyxFQUFFLFFBQVEsRUFBQyxHQUFHO1FBQzVFLEdBQUcseUJBQXlCO1FBQzVCLFdBQVcsRUFBRSxRQUFRO1FBQ3JCLFNBQVMsRUFBRSxRQUFRO1FBQ25CLEdBQUcsUUFBUTtLQUNkLENBQUM7SUFFRixNQUFNLE9BQU8sR0FBRyxNQUFNLENBQUMsUUFBUSxDQUFDLFNBQVMsQ0FBQztRQUN0QyxDQUFDLENBQUMsWUFBWSxDQUFDLEVBQUMsS0FBSyxFQUFFLFNBQVMsRUFBRSxNQUFNLEVBQUUsUUFBUSxFQUFDLENBQUM7UUFDcEQsQ0FBQyxDQUFDLEtBQUssQ0FBQztJQUNaLE1BQU0saUJBQWlCLEdBQUcsTUFBTSxDQUFDLElBQUksQ0FBQyxLQUFLLENBQUMsSUFBSSxDQUFDLEdBQUcsQ0FBQyxPQUFPLENBQUMsQ0FBQyxDQUFDLENBQUM7SUFFaEUsSUFBSSxrQkFBa0IsR0FBRyx3QkFBd0IsQ0FBQyxPQUFPLEVBQUUsU0FBUyxDQUFDLENBQUM7SUFDdEUsTUFBTSxXQUFXLEdBQUcsTUFBTSxDQUFDLGtCQUFrQixDQUFDLEdBQUcsQ0FBQyxDQUFDO0lBRW5ELElBQUksTUFBTSxDQUFDLFFBQVEsQ0FBQyxTQUFTLENBQUMsRUFBRTtRQUM1QixJQUFJLFdBQVcsS0FBSyxRQUFRLElBQUksQ0FBQyxXQUFXLElBQUksV0FBVyxLQUFLLEtBQUssQ0FBQyxFQUFFO1lBQ3BFLE1BQU0sZUFBZSxHQUFXLElBQUksQ0FBQyxHQUFHLENBQ3BDLFNBQVMsR0FBRyxrQkFBa0IsQ0FBQyxNQUFNLEVBQ3JDLENBQUMsQ0FDSixDQUFDO1lBQ0YsTUFBTSxjQUFjLEdBQUcsR0FBRyxDQUFDLE1BQU0sQ0FBQyxlQUFlLENBQUMsQ0FBQztZQUVuRCxrQkFBa0IsR0FBRyxHQUFHLGtCQUFrQixHQUFHLGNBQWMsRUFBRSxDQUFDO1NBQ2pFO2FBQU07WUFDSCxrQkFBa0IsR0FBRyxrQkFBa0IsQ0FBQyxPQUFPLENBQUMsS0FBSyxFQUFFLEVBQUUsQ0FBQyxDQUFDO1NBQzlEO0tBQ0o7SUFFRCxNQUFNLFNBQVMsR0FBRyxpQkFBaUIsQ0FBQyxNQUFNLEdBQUcsQ0FBQyxDQUFDO0lBQy9DLE1BQU0sSUFBSSxHQUFHLEtBQUssR0FBRyxDQUFDLENBQUMsQ0FBQyxDQUFDLFdBQVcsQ0FBQyxDQUFDLENBQUMsRUFBRSxDQUFDO0lBQzFDLElBQUksTUFBTSxHQUFHLElBQUksR0FBRyxpQkFBaUIsQ0FBQyxNQUFNLENBQUMsQ0FBQyxDQUFDLENBQUM7SUFFaEQsS0FBSyxJQUFJLENBQUMsR0FBRyxDQUFDLEVBQUUsQ0FBQyxHQUFHLGlCQUFpQixDQUFDLE1BQU0sRUFBRSxDQUFDLEVBQUUsRUFBRTtRQUMvQyxJQUFJLENBQUMsR0FBRyxDQUFDLEtBQUssU0FBUyxJQUFJLGlCQUFpQixDQUFDLE1BQU0sR0FBRyxDQUFDLEVBQUU7WUFDckQsTUFBTSxJQUFJLGlCQUFpQixDQUFDO1NBQy9CO1FBRUQsTUFBTSxJQUFJLGlCQUFpQixDQUFDLE1BQU0sQ0FBQyxDQUFDLENBQUMsQ0FBQztLQUN6QztJQUVELE9BQU8sa0JBQWtCLENBQUMsQ0FBQyxDQUFDLE1BQU0sR0FBRyxnQkFBZ0IsR0FBRyxrQkFBa0IsQ0FBQyxDQUFDLENBQUMsTUFBTSxDQUFDO0FBQ3hGLENBQUMiLCJzb3VyY2VzQ29udGVudCI6WyJpbXBvcnQge0NIQVJfSFlQSEVOfSBmcm9tICdAdGFpZ2EtdWkvY2RrL2NvbnN0YW50cyc7XG5pbXBvcnQge3R1aVJvdW5kV2l0aH0gZnJvbSAnQHRhaWdhLXVpL2Nkay91dGlscy9tYXRoJztcbmltcG9ydCB7XG4gICAgVFVJX0RFRkFVTFRfTlVNQkVSX0ZPUk1BVCxcbiAgICB0eXBlIFR1aU51bWJlckZvcm1hdFNldHRpbmdzLFxufSBmcm9tICdAdGFpZ2EtdWkvY29yZS90b2tlbnMnO1xuXG5pbXBvcnQge3R1aUdldEZyYWN0aW9uUGFydFBhZGRlZH0gZnJvbSAnLi9nZXQtZnJhY3Rpb25hbC1wYXJ0LXBhZGRlZCc7XG5cbi8qKlxuICogRm9ybWF0cyBudW1iZXIgYWRkaW5nIGEgdGhvdXNhbmQgc2VwYXJhdG9ycyBhbmQgY29ycmVjdCBkZWNpbWFsIHNlcGFyYXRvclxuICogcGFkZGluZyBkZWNpbWFsIHBhcnQgd2l0aCB6ZXJvZXMgdG8gZ2l2ZW4gbGVuZ3RoXG4gKlxuICogQHBhcmFtIHZhbHVlIHRoZSBpbnB1dCBudW1iZXJcbiAqIEBwYXJhbSBzZXR0aW5ncyBTZWUge0BsaW5rIFR1aU51bWJlckZvcm1hdFNldHRpbmdzfVxuICogQHJldHVybiB0aGUgZm9ybWF0dGVkIHN0cmluZ1xuICovXG5leHBvcnQgZnVuY3Rpb24gdHVpRm9ybWF0TnVtYmVyKFxuICAgIHZhbHVlOiBudW1iZXIsXG4gICAgc2V0dGluZ3M6IFBhcnRpYWw8VHVpTnVtYmVyRm9ybWF0U2V0dGluZ3M+ID0ge30sXG4pOiBzdHJpbmcge1xuICAgIGNvbnN0IHtwcmVjaXNpb24sIGRlY2ltYWxTZXBhcmF0b3IsIHRob3VzYW5kU2VwYXJhdG9yLCBkZWNpbWFsTW9kZSwgcm91bmRpbmd9ID0ge1xuICAgICAgICAuLi5UVUlfREVGQVVMVF9OVU1CRVJfRk9STUFULFxuICAgICAgICBkZWNpbWFsTW9kZTogJ2Fsd2F5cycsXG4gICAgICAgIHByZWNpc2lvbjogSW5maW5pdHksXG4gICAgICAgIC4uLnNldHRpbmdzLFxuICAgIH07XG5cbiAgICBjb25zdCByb3VuZGVkID0gTnVtYmVyLmlzRmluaXRlKHByZWNpc2lvbilcbiAgICAgICAgPyB0dWlSb3VuZFdpdGgoe3ZhbHVlLCBwcmVjaXNpb24sIG1ldGhvZDogcm91bmRpbmd9KVxuICAgICAgICA6IHZhbHVlO1xuICAgIGNvbnN0IGludGVnZXJQYXJ0U3RyaW5nID0gU3RyaW5nKE1hdGguZmxvb3IoTWF0aC5hYnMocm91bmRlZCkpKTtcblxuICAgIGxldCBmcmFjdGlvblBhcnRQYWRkZWQgPSB0dWlHZXRGcmFjdGlvblBhcnRQYWRkZWQocm91bmRlZCwgcHJlY2lzaW9uKTtcbiAgICBjb25zdCBoYXNGcmFjdGlvbiA9IE51bWJlcihmcmFjdGlvblBhcnRQYWRkZWQpID4gMDtcblxuICAgIGlmIChOdW1iZXIuaXNGaW5pdGUocHJlY2lzaW9uKSkge1xuICAgICAgICBpZiAoZGVjaW1hbE1vZGUgPT09ICdhbHdheXMnIHx8IChoYXNGcmFjdGlvbiAmJiBkZWNpbWFsTW9kZSA9PT0gJ3BhZCcpKSB7XG4gICAgICAgICAgICBjb25zdCB6ZXJvUGFkZGluZ1NpemU6IG51bWJlciA9IE1hdGgubWF4KFxuICAgICAgICAgICAgICAgIHByZWNpc2lvbiAtIGZyYWN0aW9uUGFydFBhZGRlZC5sZW5ndGgsXG4gICAgICAgICAgICAgICAgMCxcbiAgICAgICAgICAgICk7XG4gICAgICAgICAgICBjb25zdCB6ZXJvUGFydFN0cmluZyA9ICcwJy5yZXBlYXQoemVyb1BhZGRpbmdTaXplKTtcblxuICAgICAgICAgICAgZnJhY3Rpb25QYXJ0UGFkZGVkID0gYCR7ZnJhY3Rpb25QYXJ0UGFkZGVkfSR7emVyb1BhcnRTdHJpbmd9YDtcbiAgICAgICAgfSBlbHNlIHtcbiAgICAgICAgICAgIGZyYWN0aW9uUGFydFBhZGRlZCA9IGZyYWN0aW9uUGFydFBhZGRlZC5yZXBsYWNlKC8wKiQvLCAnJyk7XG4gICAgICAgIH1cbiAgICB9XG5cbiAgICBjb25zdCByZW1haW5kZXIgPSBpbnRlZ2VyUGFydFN0cmluZy5sZW5ndGggJSAzO1xuICAgIGNvbnN0IHNpZ24gPSB2YWx1ZSA8IDAgPyBDSEFSX0hZUEhFTiA6ICcnO1xuICAgIGxldCByZXN1bHQgPSBzaWduICsgaW50ZWdlclBhcnRTdHJpbmcuY2hhckF0KDApO1xuXG4gICAgZm9yIChsZXQgaSA9IDE7IGkgPCBpbnRlZ2VyUGFydFN0cmluZy5sZW5ndGg7IGkrKykge1xuICAgICAgICBpZiAoaSAlIDMgPT09IHJlbWFpbmRlciAmJiBpbnRlZ2VyUGFydFN0cmluZy5sZW5ndGggPiAzKSB7XG4gICAgICAgICAgICByZXN1bHQgKz0gdGhvdXNhbmRTZXBhcmF0b3I7XG4gICAgICAgIH1cblxuICAgICAgICByZXN1bHQgKz0gaW50ZWdlclBhcnRTdHJpbmcuY2hhckF0KGkpO1xuICAgIH1cblxuICAgIHJldHVybiBmcmFjdGlvblBhcnRQYWRkZWQgPyByZXN1bHQgKyBkZWNpbWFsU2VwYXJhdG9yICsgZnJhY3Rpb25QYXJ0UGFkZGVkIDogcmVzdWx0O1xufVxuIl19